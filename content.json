{"pages":[{"title":"404","text":"你来到了一片荒原 body { background-color: #26292E; color: #2E2F30; font-family: sans-serif; margin: 0; } footer { position: absolute; bottom: 1%; width: 100%; text-align: center; font-size: .6em; color: #fff } a { color: #fff; } a:hover { color: #e74c3c; } .dialog { float:right; text-align: left; width: 60%; margin: 5% auto 0; } h1 { font-size: 4em; color: #fff; line-height: 1em; } p { font-size: 1.4em; color: #fff; padding-right: 5%; } .image { position: absolute; float: left; top: 0; width:60%; } @media only screen and (max-width: 767px) { .image { width: 100%; top: -50px; } .dialog { float:none; text-align: center; width: 90%; margin-top: 70% } } Hey, who turned off the lights? 你来到了一片未知的空间,几秒钟后将你传送回主页 notesail.com","link":"/404.html"},{"title":"","text":"bJ6YghFiX0","link":"/baidu_verify_bJ6YghFiX0.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"","text":"欢迎留言交换友链 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"","text":"Fineserver作品展这里的截图都来源于Minecraft基岩版服务器Fineserver中的玩家，记录大家的作品(部分建筑作者未知)。 建议点击右上角关闭夜间模式观看 此外，部分建筑还会上传建筑的模型文件以及结构文件，模型文件可以使用3d模型查看软件进行浏览，也可以下载到本地之后上传到Babylonjs的沙盒进行浏览如何操作?，而结构文件可以用结构方块导入。 欢迎遵守规则的玩家加群游玩，需要先加入审核群~ 加入FINE补习班 主城区 主城周边建筑 云中镇 大秦王朝 其他区域 功能设施 如何查看3d模型文件 3d模型在线查看 主城区 主城周边建筑 云中镇云中镇是Fineserver中最大的镇子(玩家聚居地)，有许多大佬的建筑。 大教堂3d模型下载 大秦王朝汉家伊洛九重城，御路浮桥万里平。 桂户雕梁连绮翼，虹梁绣柱映丹楹。 朝光欲动千门曙，丽日初照百花明 洛阳繁华，秦王为最，fine洛阳秦王再现今朝，会古风会古都设计的快来和我一起让千古一帝的古今遗迹在现当代吧。————Dueki r i t o93 其他区域功能设施 如何查看3d模型文件下载了.glb格式的3d模型文件该如何查看呢？win10自带的3d模型浏览器就可以打开，但是感觉效果一般，我们还可以使用Babylonjs官方提供的网页来查看模型。以云中镇的小黑雕像为例。 访问https://sandbox.babylonjs.com/ 点击右下角图标或者直接把之前下载的.glb文件拖拽进去，模型上传之后便可以显示出来了 3d模型在线查看 这里我直接使用了iframe展示了Babylonjs sandbox(前往官网获取更好的体验)的网页，直接把模型文件拖到这里也可以展示 document.getElementById(\"test\").style.height=document.getElementById(\"test\").scrollWidth*0.75+\"px\";","link":"/finemc/index.html"},{"title":"messages","text":"","link":"/messages/index.html"},{"title":"","text":"IGKO7AfLHO","link":"/search/baidu_verify_IGKO7AfLHO.html"},{"title":"search","text":"","link":"/search/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"留言板","text":"欢迎给我留言哦~","link":"/message/index.html"}],"posts":[{"title":"Linux下管理Windows","text":"Linux下进行Windows管理的一些想法之前提到了为了运行某服务，我在linux服务器下使用kvm虚拟化了一个windows server出来，但是由于我之前写好的用来管理该服务的QQ机器人只能运行在linux下，又懒得去修改了，而且平时使用命令行要比远程桌面效率更高一些，所以我采取了以下几点措施来实现在linux下进行windows管理。 windows安装openssh服务，linux通过ssh控制windows windows分享文件夹，linux直接通过网络挂载该文件夹 (adsbygoogle = window.adsbygoogle || []).push({}); Windows安装openssh-server其实可以直接在系统-应用中安装，但是不知道为什么我这里卡在下载了…所以我改用手动下载安装的方式来安装openssh服务器。 前往github下载官方的openssh文件，https://github.com/PowerShell/Win32-OpenSSH/releases，将压缩包解压到*C:\\Program Files*下，并打开一个cmd或者powershell，执行 powershell.exe -ExecutionPolicy Bypass -File install-sshd.ps1安装ssh，并执行netsh advfirewall firewall add rule name=sshd dir=in action=allow protocol=TCP localport=22放行端口。 然后解压得到的文件夹中有一个ssh_config.sample的文件，我将其改名为ssh_config，并移动到C:\\ProgramData\\ssh文件夹中没有则新建该文件夹，修改ssh_config，开启root登陆(Permitrootlogin)。 之后在powershell中输入 net start sshd 如果没有问题，sshd服务就正常启动了，之后使用 ssh administrator@ip 即可连接。 如果有报错可以查看Windows openssh的github wiki，或者搜索issues。 Linux挂载Windows的共享文件夹有时候不想再开个远程桌面，或者想直接通过linux的web服务器来展示windows上的文件，那么可以采取windows共享文件夹，linux挂载该文件夹的方式来实现。在要共享的文件夹上右键，属性-&gt;共享。 之后在linux上挂载也很简单，mount -t cifs -o username=Administrator,password=password //192.168.0.200/bdx /home/minecraft/windows/ 即可成功挂载。","link":"/posts/linux-manage-windows.html"},{"title":"使用Chevereto自建图床","text":"Chevereto自建图床免费的图床用过很多，但是用免费的公共图床有一个巨大的风险，万一那天图床跑路了或者倒闭了，你的图就全部”裂开了”，而且你也大概率找不到以前写一篇文章的时候到底都用了哪些图片…之前这个博客里很多图片用的阿里云oss作为图床，阿里云的速度的确快，并且数据也要安全得多，但是如果访问量较大(当然我的网站都远远达不到那个程度)流量费用也会用掉不少钱，所以为了图片不”裂开”其实也是为了折腾着玩，我用我的一台国外服务器使用chevereto搭建了一个图床自用。 其实自建图床也有挺大的风险，其实最稳的还是使用对象储存服务 如果机器”不慎”被删除，你的数据就全丢了 如果你域名不想续费了，得修改数据库中的图片路径，以及你写过的文章中的图片路径 如果要换服务器迁移起来也挺麻烦的 安装lnmp环境Chevereto同样需要lnmp环境，具体的安装方法我在ubuntu手动安装lnmp+Typecho这篇文章里有写，这里就不赘述了，大概说一下不同的地方就好。 我在/etc/nginx/sites-available新建了一个站点配置文件，名为img，内容大概如下: 1234567891011121314151617181920212223242526server { root /var/www/html/Chevereto; # Add index.php to the list if you are using PHP index index.html index.htm index.nginx-debian.html index.php; server_name source.mytor.ch; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } location ~ \\.php$ { include snippets/fastcgi-php.conf; fastcgi_pass unix:/var/run/php/php7.2-fpm.sock; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; } listen 443 ssl;}server { server_name source.mytor.ch; listen 80; return 404; } 然后建立软链接ln -s /etc/nginx/sites-available/img /etc/nginx/sites-enable/使用certbot自动配置证书,并设置http到https的重定向。 另外创建chevereto数据库(至于怎么做另一篇文章里都有写)，用户，并赋权。 配置php,nano /etc/php/7.2/fpm/php.ini,修改了上传文件的上限以及内存使用的上限。 12345post_max_size = 200Mmemory_limit = 1024Mmax_execution_time = 360upload_max_filesize = 200Mdate.timezone = Asia/Shanghai 使用systemctl restart php7.2-fpm重启php。 (adsbygoogle = window.adsbygoogle || []).push({}); 安装Chevereto我直接采用了安装器安装的方式，在/var/www/html下新建一个名为Chevereto的目录，下载installer.php并上传，目录权限设置为755，用户设为www-data:www-data即可，然后访问域名如 https://source.mytor.ch/installer.php，进入到安装配置页面，首先他会检测你的路径以及web服务器，并提示你需要添加一些服务器规则到站点配置文件中，点击**server rules就可以看到了,在我这里需要像img站点文件的server大括号中添加如下内容，并重启服务器。如果不做这一步，之后的安装会失败。 1234567891011121314151617181920212223# Chevereto nginx generated rules for https://source.mytor.ch/## Disable access to sensitive fileslocation ~* /(app|content|lib)/.*\\.(po|php|lock|sql)$ { deny all;}## CORS headerslocation ~* /.*\\.(ttf|ttc|otf|eot|woff|woff2|font.css|css|js) { add_header Access-Control-Allow-Origin &quot;*&quot;;}## Upload path for image content only and set 404 replacementlocation ^~ /images/ { location ~* (jpe?g|png|gif) { log_not_found off; error_page 404 /content/images/system/default/404.gif; } return 403;}## Pretty URLslocation / { index index.php; try_files $uri $uri/ /index.php?$query_string;}# END Chevereto nginx rules 完成配置后，设置好数据库用户/密码/数据库名字等信息之后，便可以开始安装了。 安装成功之后，我们的自建图床就可以访问啦。 额外设置我还进行了一些额外设置。使用管理员账号登陆后，点击右上角即可进入图床设置仪表盘。 在这里我修改了禁止注册(因为是私人图床)，禁止游客上传，修改了上传图片的大小限制等等操作。 另外，在上传主题图片的时候出现了 nginx: 413 Request Entity Too Large 的错误，原来只修改php的上传设置还不行，还需要修改nginx的设置，编辑/etc/nginx/nginx.conf，在http{}中加入client_max_body_size 200m; 然后重启nginx即可。 搭配CDN使用因为欧洲的服务器在大陆访问速度不稳定，我考虑搭配cloudflare使用，如果是直接使用cloudflare的域名服务器，那很简单，直接把cdn的开关打开，云朵变成橙色就好了，但是我采用的是cname接入的方式，那就麻烦一些。现在图床的源站域名是 img.mytor.ch，我们要去cloudflare partner里添加CNAME接入，如 img.cdn.mytor.ch-》img.mytor.ch，再去dnspod里面添加CNAME记录，将img.cdn.mytor.ch 解析到 source.mytor.ch.cdn.cloudflare.net （partner提供的CNAME值），还需要在站点配置文件里面同时设置两个域名的根目录，http转https等配置(直接并列写上去就好了如 server_name source.mytor.ch mytor.ch)，等一段时间后生效即可，之后使用图床可以访问imgs.cdn.mytor.ch即可。之后还要去chevereto的设置-外部服务里面设置cdn链接以及开启cloudflare，不然无法上传图片。 (adsbygoogle = window.adsbygoogle || []).push({});","link":"/posts/chevereto-imgbed.html"},{"title":"安卓使用metasploit","text":"安卓使用metasploit-framework昨天碰到了一个服务器面板，管理员账户名已知，闲的没事干便想着猜测一下密码是什么，没想到居然是 “123456” 这样的极弱密码，猜了两次就猜出来了，一次成功之后手又有点痒了，不如在手机上装上nmap, metasploit-framework等工具，无聊的时候可以学习一下”网络安全”知识。 Termux 安装metasploit当然在安卓系统中我们是没办法直接使用这些工具的，于是我是用了termux创建了一个linux的环境，详细配置可以查看Termux 高级终端安装使用配置教程。按照教程可以直接安装nmap,sqlmap等工具，但毕竟是18年的教程了，一些软件包发生了变化，比如没办法直接使用文章中的方法安装metasploit框架了，根据termux wiki，当前版本的源中已经添加了metasploit，不过该软件位于unstable-repo源中，我们首先要执行pkg install unstable-repo添加该源，！！注意，清华源，科大源等国内termux源虽然下载速度很快，但是软件包不全/某些包版本过老，会导致安装失败，所以接下来的操作请使用默认的官方源 在添加了unstable-repo之后执行apt update，之后即可直接使用apt install metasploit安装 msf框架了，注意，由于该源在国外，安装极其缓慢，而且有时可能会因为网络状况不好而安装失败，我花了一个多小时才下载安装完毕，请耐心等待，一个网络不行尝试一下其它的网络。 以前在kali linux上安装好metasploit框架还需要进行配置数据库连接等操作，不过在termux中这些操作都可省了，使用包管理器安装好的msf框架已经是配置完毕的状态了，执行msfconsole即可进入。 使用frp进行代理当我们尝试使用metasploit进行某些攻击的时候需要宿主机连接我们的手机，比如我们生成病毒的时候使用的windows/meterpreter/reverse_tcp载荷，但是我们的手机没有公网ip怎么远程控制宿主机呢？我们可以使用frp来进行代理，至于怎么操作，该项目的readme已经说的很详细了。 当然这是一个不太好的方法，被攻击者完全可以通过你使用的代理服务器的ip找出你的信息（当然你要是能隐藏好这些信息也行），另外我还遇到了一个问题就是frpc.ini配置文件中，host不能使用域名，原因是frp使用的go语言使用到的net模块是通过/etc/resolv.conf获得dns服务器地址的而android系统中没有/etc/resolv.conf文件，会导致域名无法解析，解决方法有很多，比较简单的就是直接填写ip即可，另外可以参考#issue700 。 生成木马进行攻击有空再补全… 参考 Termux 高级终端安装使用配置教程 关于 meterpreter 持久化问题研究 Metasploit 「控制持久化」权限维持","link":"/posts/android-metasploit.html"},{"title":"Minecraft基岩版服务器(bds)怎么添加行为包材质包","text":"(adsbygoogle = window.adsbygoogle || []).push({}); BDS添加行为包与材质包Minecraft Bedrock Dedicated Server不同于其它的第三方服务端，它是支持添加材质包行为包的(虽然截止1.13添加新方块的行为包依旧无法生效)，尽管bedrock_server_how_to.html里面说了目前还没有办法直接启用行为包/材质包，但是我们依旧是有办法添加包到服务器上并启用的，添加行为包和材质包的方法相似，这里以添加行为包为例。 首先在存档文件夹（以我的存档文件夹路径为例，level-name为fine时路径为 /home/minecraft/bds/worlds/fine ）中新建两个json文件，world_behavior_packs.json 与 world_resource_packs.json，然后将我们要添加的包（文件夹形式，后缀.mcpack其实就是.zip文件，修改后缀为.zip解压到文件夹中即可）移动到bds下的 behavior_packs/ 文件夹中，之后查看行为包中的 manifest.json，json结构如下: 1234567891011121314151617181920212223242526{ \"format_version\" : 1, \"header\" : { \"description\" : \"超凶猫的行为包,很凶的！\", \"name\" : \"超凶猫的行为包\", \"platform_locked\" : false, \"uuid\" : \"460363a2-c458-4da5-84a9-56dc6dc88a6d\", \"min_engine_version\" : [ 1, 12, 0 ], \"version\" : [ 0, 0, 8 ] }, \"modules\" : [ { \"description\" : \"超凶猫的行为包\", \"type\" : \"data\", \"uuid\" : \"fbcaf43a-646c-48ae-aa00-3f1c3db019bc\", \"version\" : [ 0, 0, 8 ] } ], \"dependencies\": [ { \"uuid\": \"9c091fc5-12e2-4121-b5bd-8868ce45a45e\", \"version\": [0, 0, 3] } ], \"capabilities\": [ \"experimental_custom_ui\", \"chemistry\" ]} 里面信息有很多，但是我们只需要复制出header中的uuid与version即可，编辑刚才在存档文件夹中新建的world_behavior_packs.json格式如下（以多个行为包为例子，注意uuid要改成pack_id）： 12345678910[ { \"pack_id\": \"460363a2-c458-4da5-84a9-56dc6dc88a6d\", \"version\": [0, 0, 8] }, { \"pack_id\": \"018718bc-ed21-42be-841d-839bc7eb1ca1\", \"version\": [0, 0, 0] }] 格式必须符合JSON的标准，如果出错，行为包是不会加载的，材质包同上。 (adsbygoogle = window.adsbygoogle || []).push({});","link":"/posts/bds-packs-add.html"},{"title":"Minecraft Websocket 服务器","text":"Minecraft websocket 服务器 这两天学习了nodejs，于是想着做点什么来实践一下，正好对Minecraft 基岩版的websocket功能比较感兴趣，于是做了一个websocket服务器的demo，可以用来获得游戏内的信息以及执行命令。 准备 在服务器上使用Websocket 不少人已经在bds服务器上尝试过使用wsserver/connect命令了吧？但是这条命令不知道为什么是不能直接使用的，要想使用这条命令我们需要做以下准备。 获得op权限 只有op可以执行这条命令 修改权限等级 修改服务器配置文件server.proterties，加入一行op-permission-level = 4，使op拥有与控制台同级的命令权限 做完上述操作之后就可以使用/connect命令了，当然如果只是输入/connect，会提示Command version mismatch，这里我们暂时不管它。 上代码 我使用的使nodejs+typescript的方式创建了这个demo，只有3个文件。注释已经写的很清楚了，有问题就留下评论吧。 app.ts server.ts packet.ts 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192//app.ts 用于启动程序，端口可以在这里设置import {WSServer} from './server';let server = new WSServer();server.listen(6800);&lt;/code&gt;&lt;/pre&gt;//server.ts 包含ws服务器类,用于创建server对象import { Packet,UnSubscribe,Subscribe,CommandPacket } from './packet/packet';import { Server } from 'ws';import {EventEmitter} from 'events';import { Socket } from 'net';import {createInterface} from 'readline';//import {v4} from 'uuid';let uuid4 = require('uuid/v4');//创建一个负责输入输出的对象const rl = createInterface({ input: process.stdin, output: process.stdout});export class WSServer extends EventEmitter{ //strictPropertyInitialization:false _socket:Server; public listen(port:number):void{ let server:WSServer = this; this._socket = new Server({port:port}); //当有客户端连接时回调 console.log(\"WS开始监听\" + port); this._socket.on(\"connection\",socket =&gt; { console.log(\"客户端连接\"); //发送subscribe包建立监听 registerSubscribe(socket,\"PlayerMessage\"); registerSubscribe(socket,\"BlockPlaced\"); //当socket收到信息时回调 socket.on(\"message\", message =&gt; { console.log(\"接收到客户端的信息\"); let data = JSON.parse(message as string); let msgPurpose = data.header.messagePurpose; if(msgPurpose == \"error\"){ console.log(\"出现错误:\", data); } else if(msgPurpose == \"event\"){ console.log(data.body.eventName); //发送unsubscribe包，取消对该事件的监听，具体表现为服务端只能获得一次客户端的方块放置事件 if (data.body.eventName == \"BlockPlaced\"){ sendCommand(socket,&lt;code&gt;say 发送unsubscribe包解除对方块放置事件的监听&lt;/code&gt;); unRegisterSubscribe(socket,\"BlockPlaced\"); } } else if(msgPurpose == \"commandResponse\"){ console.log(\"命令返回：\" + data.body.statusCode); } }); //接收到控制台的发送信息事件 server.on(\"sendMsg\",msg=&gt;{ console.log(\"[sendMsg]:\" + msg); sendCommand(socket,&lt;code&gt;say ${msg}&lt;/code&gt;); }); socket.on(\"error\",err=&gt;{ console.log(\"建立的socket出现错误\" + err.message); }); socket.on(\"close\", () =&gt; {console.log(\"客户端断开连接\")}); }); this._socket.on(\"error\",error=&gt;{ console.log(&lt;code&gt;出现错误${error}&lt;/code&gt;); }); //持续获得用户输入 rl.on('line', (input) =&gt; { console.log(&lt;code&gt;[consoleInput]：${input}&lt;/code&gt;); let [cmd,content] = input.split(\":\"); if(cmd == \"send\"){ //触发sendMsg事件 server.emit(\"sendMsg\",content); } else if(cmd == \"exit\"){ process.exit(); } }); }}function registerSubscribe(socket:any,eventName:string):void{ let packet:Subscribe = new Subscribe(eventName); socket.send(JSON.stringify(packet));}function unRegisterSubscribe(socket:any,eventName:string):void{ let packet:UnSubscribe = new UnSubscribe(eventName); socket.send(JSON.stringify(packet));}function sendCommand(socket:any,command:string):void{ let packet:CommandPacket = new CommandPacket(command); socket.send(JSON.stringify(packet));}&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;//packet 这里是三种数据包的类let uuid4 = require('uuid/v4');//数据包export abstract class Packet{ body:{}; header:{};}export class Subscribe extends Packet{ body:{ eventName: string; }; header:{ requestId: string; messagePurpose: string; version: number; messageType: string; }; constructor(eventName:string){ super(); this.body = { eventName:eventName }; this.header = { requestId: uuid4(), messagePurpose: \"subscribe\", version: 1, messageType: \"commandRequest\" }; }}export class UnSubscribe extends Packet{ body:{ eventName: string; }; header:{ requestId: string; messagePurpose: string; version: number; messageType: string; } constructor(eventName:string,uuid = uuid4()){ super(); this.body = { eventName: eventName }; this.header = { requestId: uuid, messagePurpose: \"unsubscribe\", version: 1, messageType: \"commandRequest\" } }}export class CommandPacket extends Packet{ body:{}; header:{}; constructor(cmd:string){ super(); this.body = { origin: { type: \"player\" }, commandLine: cmd, version: 1 }; this.header = { requestId: uuid4(), messagePurpose: \"commandRequest\", version: 1, messageType: \"commandRequest\" }; }} 运行程序 如果想部署一个ws服务器试试看 1234git clone https://github.com/aoyouer/BedrockWsServer.gitcd BedrockWsServernpm installnode build/app.js #默认使用6800端口 之后我们在游戏里即可使用 /connect ip:6800 连接ws服务器了，但是不知道为什么，我在自己的电脑(win10)上运行的ws服务器可以通过浏览器访问，但是无法在游戏中连接，在我将程序放到远程的服务器上才正常连接。 在这个demo中，我尝试发送/接收了mc中文wiki ws教程中提到的几种数据包 subscribe 用于监听一个事件，当用户成功连接以后，我们依旧是无法获得用户相关的信息的，我们需要发送subscribe包表明我们对哪些数据\"感兴趣\"，之后客户端才会通过ws发送给我们。在demo中我发送了两个时间的subscribe包，分别是 \"PlayerMessage\" 表示用户发送信息 与 \"BlockPlaced\" 表示用户放置方块这两个事件，我没有取出更多信息，感兴趣的朋友可以查看返回的json，并取出详细信息。 unsubscribe 当我们对一个事件不再感兴趣之后，可以发送unsubscribe包解除对此事件的接收，在demo中，我在接收到了一个“BlockPlaced”事件之后即发送该事件的unsubscribe包，因此我们只会接收到一次BlockPlaced事件。 commandrequest 该数据包用于执行命令，在demo中，你只需要在程序运行的后台中输入 send:你想发送的信息 按下回车后，程序即会构建一个执行 say 你想发送的信息的命令的数据包并发送，还会获得该命令执行的结果。 在后台输入exit退出程序。 总结 写这个小程序算是加深了一些我对nodejs的了解，Minecraft基岩版的websocket虽然看上去可以获得很多信息，但是在我看来，它的功能还是相当有限的，因为有几个巨大的限制 只有op在客户端上才能执行，而不是bds服务端直接连接另一个websocket服务端 要想保持连接需要op持续在线 因为这些限制，我暂时想不出什么有趣的应用方向(也许之后我会慢慢扩展这个项目)，不过github上依旧有几个比较成熟的基于Minecraft websocket的项目可以了解一下 通过ws来生成一个agent并进行控制 大名鼎鼎的fastbuild，利用ws快速建造 参考链接 https://minecraft-zh.gamepedia.com/%E6%95%99%E7%A8%8B/WebSocket https://minecraft-zh.gamepedia.com/%E6%95%99%E7%A8%8B/WebSocket https://github.com/eDroiid/BedrockWS","link":"/posts/minecraft-websocket.html"},{"title":"docker图片中文显示乱码/显示方块解决方法","text":"docker smokeping中文无法正常显示在通过docker配置好了smokeping之后，我遇到了一个问题，当涉及到需要docker中的程序生成图片并提供访问的时候，图片中的中文都无法正常显示，而是显示成了一个个方块，今天查阅了相关资料，解决了这个问题。 docker安装中文字体图片中的中文显示为乱码大概率是因为docker容器中缺少中文字体，只要我们把字体装上就好了。以alpine系统为例(现在很多docker开始使用alpine作为系统，因为他足够轻量占用的资源也少)。 12echo @edge http://nl.alpinelinux.org/alpine/edge/testing &gt;&gt; /etc/apk/repositories &amp;&amp; apk add wqy-zenhei@edgeapk add wqy-zenhei --update-cache --repository http://nl.alpinelinux.org/alpine/edge/testing --allow-untrusted 之后刷新网页，发现中文已经可以正常显示了。 (adsbygoogle = window.adsbygoogle || []).push({});","link":"/posts/docker-chinese-support.html"},{"title":"golang-telegram机器人初探","text":"Golang Telegram机器人初探最近学习了golang，想着先写个什么项目来练练手，正好现在telegram使用的比较的多，手上又有比较多的服务器，虽说已经有了网页探针但是想着要是能用机器人实现一个服务器探针，显示服务器状态并在服务器出现掉线等情况的时候发消息通知一下好像也挺不错。 起步首先在TG里面找到机器人之父@BotFather创建我们的机器人，输入相关信息后我们便能得到机器人的token。 接着在我们的开发环境中编译安装Golang版本的Telegram机器人api。 https://github.com/go-telegram-bot-api/telegram-bot-api go get -u github.com/go-telegram-bot-api/telegram-bot-api (确保已经安装了git等go get需要的依赖) 尝试一下github页面上提供的“复读机”demo，记得替换MyAwesomeBotToken为你自己的机器人的token。 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"log\" \"github.com/go-telegram-bot-api/telegram-bot-api\")func main() { bot, err := tgbotapi.NewBotAPI(\"MyAwesomeBotToken\") if err != nil { log.Panic(err) } bot.Debug = true log.Printf(\"Authorized on account %s\", bot.Self.UserName) u := tgbotapi.NewUpdate(0) u.Timeout = 60 updates, err := bot.GetUpdatesChan(u) for update := range updates { if update.Message == nil { // ignore any non-Message Updates continue } log.Printf(\"[%s] %s\", update.Message.From.UserName, update.Message.Text) msg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text) msg.ReplyToMessageID = update.Message.MessageID bot.Send(msg) }} 然后使用go run bot.go，再向你的机器人发送一则信息，可以看见机器人成功复读。 开发准备阅读官方的BOT开发介绍文本，以及api文档了解一下bot可以做什么，以及大概有哪些接口。 Telegram Bot和真实的用户账户有以下不同: 无在线状态或者上一次活跃时间，以机器人表示取而代之 机器人的云储存空间相对有限，老的信息会在被处理后的不久被删除 机器人不能主动对用户发起对话，除非被用户添加到群组或者用户向机器人先发送了信息。 默认情况下，被加入群组后机器人不会接收所有的信息 而BOT还可以进行一些特殊的操作，比如两种键盘，额外的命令接口，文本格式化等等，具体查看下文。 行内模式 用户可以采用行内模式与机器人交互，即在文本输入框内用@botusername开头并输入请求，用户可以在他们的聊天或者群组/频道力使用该模式交互，用户输入内容后，即使还没有点击发送，但是机器人已经可以接收到请求。demo 支付平台 Telegram 机器人可以发送一则包含了商品信息的信息并带上支付按钮，用户点击后可以在tg内打开支付接口，使用信用卡、apple pay等方式支付。 游戏平台 机器人可以向用户提供html5游戏，并可以记录玩家的得分 键盘 机器人可以在用户的设备上显示虚拟的预设键盘，用以获得用户的“规整一些”的输入，当机器人发送信息的时候可以传递一个特殊的预定义的键盘，应用程序接收到后会把键盘展示出来，点击其中的按钮，信息会马上被发送到聊天页面中，通过这种方式可以大幅简化用户和机器人的交互(该键盘更多的是起到一个快速的，使用预设回复的功能) 内联键盘 除了在输入框之下显示键盘，bot还可以直接在信息底部显示键盘，和上面的键盘不一样，内联键盘的按键按下后并不会把信息发送到聊天中,而是触发后台的工作。 Instead, inline keyboards support buttons that work behind the scenes: callback buttons, URL buttons and switch to inline buttons. 如使用callback 按钮，机器人可以更新已有的信息或者键盘，可以让聊天看起来整洁一些。可以查看下面的几个机器人@music, @vote, @like。 命令 用户还可以通uff过命令来和机器人交互。命令总是以/开头，不能超过32个字符，可以使用拉丁字符数字和下划线。用斜杠开头的信息总会被传递给机器人，包括对于该信息的回复以及@机器人的信息。 Telegram应用会在用户输入/后进行提示(需要开发者向BotFather提供命令的列表)，点击提示即可直接发送命令。命令在聊天中也会高亮显示，若其他用户也点击了命令，命令也会立即发送。如果多个机器人在同一个群组中，对于同名的命令，可以使用/command@botname的形式来发送命令。 全局命令 为了用户更好的和机器人交互，Telegram要求所有的开发者实现几个基本的命令,应用会对这几个命令提供快捷方式。 /start 用户开始和机器人进行交互 /help 返回帮助信息 /setting 返回机器人的设置界面 用户在首次向机器人发信息之前会看到/start按钮，在菜单中（机器人信息页）可以看到帮助和设置链接。 格式化 可以在信息中使用bold, italic, fixed-width text and inline links，客户端会对他们进行渲染。 Read more in the Bot API manual » 隐私模式 隐私模式下运行的机器人不会接收群组里其他用户发送的信息，它们只会接受 /开头的信息（命令 回复机器人自己发出的信息 服务信息（用户加入或者退出） 所在的频道的信息 机器人默认都是隐私模式运行的，除非机器人被设置成管理(也可以关闭)。如果要关闭管理员权限机器人的接收信息权限，需要重新添加到群组中，用户能看见当前机器人的隐私设置 深度链接 Telegram机器人有名为深度链接的机制，允许在开始机器人的时候传递额外的参数，可以是启动机器人的命令，授权码。机器人的链接如下https://t.me/&lt;bot username&gt;，我们可以添加额外的参数https://t.me/triviabot?startgroup=test ollowing a link with the start parameter will open a one-on-one conversation with the bot, showing a START button in the place of the input field. If the startgroup parameter is used, the user is prompted to select a group to add the bot to. As soon as a user confirms the action (presses the START button in their app or selects a group to add the bot to), your bot will receive a message from that user in this format: 1/start PAYLOAD PAYLOAD stands for the value of the start or startgroup parameter that was passed in the link. Deep linking Example Suppose the website example.com would like to send notifications to its users via a Telegram bot. Here’s what they could do to enable notifications for a user with the ID 123. Create a bot with a suitable username, e.g. @ExampleComBot Set up a webhook for incoming messages Generate a random string of a sufficient length, e.g. $memcache_key = &quot;vCH1vGWJxfSeofSAs0K5PA&quot; Put the value 123 with the key $memcache_key into Memcache for 3600 seconds (one hour) Show our user the button https://t.me/ExampleComBot?start=vCH1vGWJxfSeofSAs0K5PA Configure the webhook processor to query Memcached with the parameter that is passed in incoming messages beginning with /start. If the key exists, record the chat_id passed to the webhook as telegram_chat_id for the user 123. Remove the key from Memcache. Now when we want to send a notification to the user 123, check if they have the field telegram_chat_id. If yes, use the sendMessage method in the Bot API to send them a message in Telegram. 计划功能","link":"/posts/go-first-tgbot.html"},{"title":"code-server打造web代码编辑环境","text":"随时随地 coding近日，微软推出了visual studio online，相当于一个web-ide,与remote deployment开发方式不同的是web-ide的前端与后端都位于服务器上，相当于只要用浏览器打开就能编写代码了，不需要再下载vscode，也不需要配置环境（当然环境要在服务器上配置好）。使用这种方式我们便可以随时随地的通过浏览器来coding，无论是用性能落后的pc还是平板甚至是手机…不过目前visual studio online没有推出自部署版本，我们只能使用Azure的服务器，这就很不好，因为付款很麻烦（价格也不低），而且Azure的服务器都位于国外，高延迟也会带来糟糕的体验，不过其实早在vs online推出之前就有第三方实现了我们想要的功能，它就是cdr/code-server。 使用docker的方式部署官方有docker的image我就直接使用docker来部署了，一来方便，二来可以给他人使用且安全性较高。 12345678#先获取imagedocker pull codercom/code-server:v2#启动容器 设置密码为password 且设置端口转发到外网的8088docker run -it -p 8088:8080 --env PASSWORD=password codercom/code-server:v2#docker的其它的一些命令docker system df -v # 查看镜像/容器等占用的空间等信息docker stats # 查看当前运行的容器的实时状况# 更多关于docker的介绍https://juejin.im/post/5b260ec26fb9a00e8e4b031a 使用code-server访问ip:port,输入密码后即可看见我们熟悉的vscode界面了，chrome中按下f11全屏体验更佳 另外，从下向上拖可以看见terminal窗口，此处显示的就是一个linux bash终端了，我们可以在这里执行apt等命令，也可以在这里安装python等环境，容器和宿主机共用内核，不过无法使用宿主机中的程序所以像是java，python等程序到这里也得重新安装一遍。 另外，如果想要修改登陆密码，可以使用systemctl stop docker停止docker运行后编辑/var/lib/docker/containers 对应id文件夹中的config.v2.json文件中的ENV PASSWORD环境变量。","link":"/posts/code-server.html"},{"title":"cloudflare自定义节点 加速访问","text":"cloudflare自选节点 加速访问之前的文章提到了，我使用了github page + coding page双部署的方法来存放我的博客，并配合dnspod智能解析，让国内用户直接访问coding page，境外直接访问github page，一方面是为了加速境内的访问，另一方面也是为了让百度蜘蛛能够顺利爬取博客的内容(因为github page是禁止了百度蜘蛛的访问的)。但是部署几天后，有人向我反馈了中国移动打开我的网站缓慢，甚至根本打不开，我一开始还以为他们解析到了github page所以访问慢，没想到一看记录，他们无法访问的ip是腾讯云新加坡的coding page…看来移动真的是令人头疼，今天我尝试使用了cloudflare并自定义节点，让移动直接访问cloudflare的香港节点，令人惊喜的是，改用cloudflare香港节点后，移动的访问速度有了挺大的提升。关于自选节点，其实网上已经有了很多教程了，不过感觉很多都比较杂乱，所以干脆写一个简洁明了一些的出来。 自选节点 (adsbygoogle = window.adsbygoogle || []).push({}); 设置CNAME接入在cloudflare的官网上，免费版用户是没办法使用CNAME接入cloudflare的，只能使用修改域名服务器接入的方式，不过在cloudflare partner的网站上我们就可以使用cname接入了，网上有不少cloudflare partner的接入平台，如萌精灵,笨牛,挖站否 ,我这以萌精灵为例。 添加CNAME记录，以本网站为例子，因为我直接就是notesail.com所以我直接添加@记录即可，指向源站，即我们加速前的网站的域名 如 example.github.io。 添加成功后，下面就会出现一条CNAME接入的记录。 复制这个CNAME，前往支持支持智能DNS的服务商处(如果想要自选节点，必须要支持智能解析)，我使用的是dnspod，添加一条CNAME记录，主机记录为@，类型CNAME，线路类型默认，记录值就填写上面这个CNAME记录。做完这一步，我们便完成CNAME接入了，如果没有其他的记录(如dnspod中的分线路解析)，我们直接访问notesail.com便是经过cdn访问了。 选择节点ip这一步很简单，比如cloudflare的香港节点对于中国移动的访问比较友好，那么我们先找出cloudflare的节点ip，这里列出一些(来自于挖站否)，更多的ip请去他们那看。 108.162.236.1/24 联通 走美国172.64.32.1/24 移动 走香港 104.16.160.1/24 电信 走美国洛杉矶 172.64.0.0/24 电信 美国旧金山104.20.157.0/24 联通 走日本104.28.14.0/24 移动 走新加坡（联通移动推荐节点）104.23.240.0-104.23.243.254（电信推荐百度云合作ip）162.159.208.4-162.159.208.103162.159.209.4-162.159.209.103162.159.210.4-162.159.210.103``162.159.211.4-162.159.211.103 比如我想加速移动的访问速度，让移动都走香港节点，那么我选用172.64.32.1这个ip(可以现在ipip.net这样的网站上看看移动节点的路由和ping值怎么样，如果你不是移动网络，不要在你本地尝试，因为anycast下电信用这个ip还是会跑到美国去的)。 选择这个节点，只需要在dnspod中添加一个A记录，主机名@，线路选移动，记录值就填写这个ip即可。等待几分钟后再用移动访问，看看速度是否快一些了呢？如果不确定自己是不是真的走了cdn节点，走的是哪个地方的节点，可以在网址后面加上/cdn-cgi/trace即可。 如我使用移动访问本站加上/cdn-cgi/trace后，colo=HKG，的确走了香港节点。 使用CDN后出现重定向次数过多的错误我们有时候在开启CDN后会出现重定向过多的错误，无法访问网站，网上的介绍如下(来自wordpress智库): Cloudflare CDN 配置 Flexible：当我们的源网站没有配置 HTTPS 支持时，启用这个选项，Cloudflare 会在回源的时候通过 HTTP 协议访问我们的网站。 Full：当我们的源网站支持 HTTPS，但是 HTTPS 证书和域名不匹配或者是自签名证书时，Cloudflare 会通过 HTTPS 协议访问源网站，但不会验证证书，也就是说，即使我们的源网站提供的 HTTPS 证书不受浏览器信任，Cloudflare 也会通过 HTTPS 回源网站。 Full(strict)：当我们的源网站支持 HTTP ，并且证书有效时（未过期且受信任）。Cloudflare 会通过 HTTPS 协议访问源网站，并在每个请求过程中验证证书。 了解了上面各个设置的功能，我们来看一下 Cloudflare 的循环重定向问题是怎么出现的，在 Cloudflare 中开启了 SSL 后，访问网站时出现循环重定向需满足下面两个条件： SSL 中设置了 Flexible，CDN 以 HTTP 协议回源网站。 源网站支持 HTTPS，并且设置了通过 HTTP 协议访问时，自动跳转到 HTTPS 协议。 到这里，可能就有朋友发现问题了，我们访问 Cloudflare 的 CDN 服务器的时候，是通过 HTTPS 访问的，CDN 访问源网站的时候，是通过 HTTP 访问的，源网站上 HTTP 又自动跳转了 HTTPS，完美的一个循环重定向。重定向的次数多了，浏览器就撂挑子报出了 ERR_TOO_MANY_REDIRECTS 的错误。 解决的方法很简单，前往cloudflare官网，ssl/tls设置中吧ssl/tls加密模式改为FULL即可。 (adsbygoogle = window.adsbygoogle || []).push({}); 参考 用Cloudflare CDN 如何自定义节点 CloudFlare免费CDN加速自定义节点-CloudFlare自选IP加快CDN速度 WordPress 网站使用 CloudFlare 后提示“将您重定向的次数过多” 的原因及解决办法","link":"/posts/cloudflare-custom.html"},{"title":"docker与wine环境配置","text":"docker与wine环境配置 因为最近感觉家里的nuc有点过于闲置了，浪费了性能，所以想着充分利用起多余的性能出租几个面板服赚点域名/vps钱，一开始只开了Minecraft基岩版服务器，不过想着最近泰拉瑞亚玩的人也挺多的，所以不如再开一个泰拉瑞亚的面板服，现在查看官网https://terraria.org/发现居然有了手机版的[专用服务端](https://terraria.org/server/MobileTerrariaServer.zip)了（上次看的时候还没有的来着），不过服务端写着 Mobile Dedicated Server for Windows ，只有Windows能用吗…虽然我也运行了一个Windows server的虚拟机，但是由于面板运行在Linux上，所以能够直接在Linux上运行该服务端就更好了，所以想到能不能用wine来运行该服务端呢？ 折腾了半天，也没有成功，wine一直无法安装上dotnet与xna运行环境，暂时搁置，这篇文章暂时记录一下docker和wine环境的配置。 创建ubuntu docker为了安全起见(面板中运行的东西不会破坏到宿主机)以及便于迁移/删除，我觉得使用docker来运行。 123docker pull ubuntudocker run -itd --name ubuntu ubuntudocker exec -it ubuntu /bin/bash 配置环境安装wine我的系统是Ubuntu20.04，安装的wine版本是wine5.0，不过在首次执行wine TerrariaServer.exe会提示需要使用wine32运行，而默认安装的是win64，只需要按照它提示的命令安装wine32即可。 注意，之前我是从apt源中安装的wine但是出了很多错误,比如缺少wine-mono之类的，直接安装也会出错，之后我改用从官网的源里面安装wine 查看winehq官网 https://wiki.winehq.org/Ubuntu_zhcn 如果您之前使用过来自发行版自己打包的安装包，您会发现它们和 WineHQ 提供的有以下不同： 文件被安装在 /opt/wine-devel 或 /opt/wine-staging。 没有为 Wine 的内置程序（winecfg 等等）创建菜单项，并且如果您是从发行版自己打包的安装包升级上来的，原来的菜单项也会被删除。您可以使用菜单编辑器自己再次创建。 没有添加 Binfmt_misc 注册项。如果您想手动添加，请查看您使用的发行版关于 update-binfmts 的文档。 WineHQ 当前没有提供 wine-gecko 和 wine-moon 的安装包。所以当创建新的 wine 配置目录时，您将会被询问是否下载这些组建。为了得到更好的兼容性，我们建议您选择“安装”。如果下载过程发生出错，请查看 Gecko 和 Mono 的 wiki 页面来进行手动安装。 从 Wine 5.7 开始，WineHQ 的 Ubuntu 安装包有一个 debconf 选项用于开启 CAP_NET_RAW 以兼容需要发送和接收 raw IP 包的应用程序。由于具有潜在的安全风险，并且大多数应用程序不需要该功能，该功能默认被关闭。需要该功能运行应用程序的用户可以在安装 Wine 之后运行 使用官方的方法 12345sudo dpkg --add-architecture i386wget -O - https://dl.winehq.org/wine-builds/winehq.key | sudo apt-key add -sudo add-apt-repository 'deb https://dl.winehq.org/wine-builds/ubuntu/ focal main'# 由于wine下载实在是太慢了，所以最好使用代理，请注意下面这样写才能生效sudo apt install -o Acquire::http::proxy=\"socks5h://192.168.0.2:1081\" --install-recommends winehq-stable 使用该方法安装的wine版本是4.0.4。实测当前ubuntu20.04安装devel分支的话无法启动。 由于直接启动的话安装mono和gecko环境过于缓慢,所以我采取了手动下载对应的wine-mono 以及gecko的方法。 在/opt/wine-stable/share路径下分别新建 mono文件夹和gecko文件夹，并从中科大的镜像http://mirrors.ustc.edu.cn/wine/wine下载这两个对应的依赖放到文件夹中，再次启动就不会卡在下载了。 参考https://www.dedoimedo.com/computers/wine-dotnet-mono.html","link":"/posts/docker-wine-env.html"},{"title":"hexo部署到coding page以及zeit.co","text":"github page coding zeit对比 把hexo生成的文件发布到coding 部署静态网站 配置自定义域名 智能解析(github page 和 coding page双部署需要设置) 效果测试 总结 之前把wordpress上的文章都迁移到了github page上，改为使用hexo生成的静态网站，但是发现百度爬虫无法爬取github page上的资源，所以考虑用coding做一个镜像站，采用双部署的方法来发布网站。 但是发现网上的绝大多数关于使用coding page(几乎所有)教程都是过时的，coding新建项目时把项目命名成xxx.coding.me之后访问显示404，找遍了网站都没找到生成page的选项。最后在一番折腾之后，在团队实名认证这里看到了进行实名认证之后可以使用静态网站的选项…终于找到了入口，实名就实名吧，填写名字身份证号以及手机号之后，马上就通过实名了。 把hexo生成的文件发布到coding这一步参照网上的教程就可以了，在coding创建一个仓库(仓库名其实无所谓)，然后获得仓库的ssh/https链接，填到hexo的_config中，hexo cl &amp;&amp; hexo d部署上去就好(ssh记得添加公匙) 顺带一提，一台电脑有多个hexo仓库或者使用多个ssh密匙的情况可以查看这个博客来解决 https://www.sugen.cn/article-20190622.html 123456789Host github.comHostName github.comUser gitIdentityFile ~/.ssh/id_rsaHost github-rsa.comHostName github.comUser gitIdentityFile ~/.ssh/github_rsa 部署静态网站实名之后还是看不到“部署page”的选项的，还需要前往项目设置(左下角)-&gt;项目与成员-&gt;功能开关 打开构建与部署功能，之后原来的左侧菜单栏中就多了一个按钮，在这选择静态网站。 选择立即部署，即可生成静态网站。 (adsbygoogle = window.adsbygoogle || []).push({}); 配置自定义域名点击右上角的设置可以前往coding page设置界面，在这里添加你的域名，并开启强制https。 智能解析(github page 和 coding page双部署需要设置)由于我的hexo主要仓库还是在github上，并且我也不打算完全转移到coding上，所以我在两边都部署了静态网站，这就需要dns pod之类的智能dns根据访问者的线路来区分应该解析到哪台服务器上了。比如我让境内的访问者访问coding page，境外的访问者访问github page。 注意，如果首先设置成这样，再申请证书会失败，我是暂时先让境内境外的dns都解析到coding然后申请证书成功之后，再修改成下图这样 效果测试之后再去百度站长工具查看百度的机器人是否可以获得站点上的文件。 直连github page由于之前的dns记录记录还没有完全更新，这里面的部分国内测试节点依旧访问了coding page(腾讯云)，但是大部分都是访问的github page ping 测试 网站打开时间 境内走coding page 境外走github pageping 测试coding page的服务器位于新加坡腾讯云，让境内访问coding page的时候ping值有不错的改善…但是在晚上测试，虽然腾讯云新加坡电信去程cn2，延迟看上去也还行，但是实际丢包惊人都是百分之五十以上的丢包率。 网站打开时间有一定的提升。 另外补充一个zeit作为cdn的比较在网上看见有人说zeit用来加速hexo博客效果不错，我也试了试。我们在注册zeit的时候会让我们和github的账号关联，并添加仓库的权限，zeit和coding不同的是它不需要我们再push上去，在一开始关联我们的github仓库之后，我们每次hexo d github仓库发生变动，zeit也会重新构建静态网页，这点比coding方便很多。 他们使用的是香港/台湾的谷歌云服务器，效果看上去还是可以的，但是免费账号每个月只有20G的流量，如果访问量较大的博客可能就不太适合了，如果要自定义域名并开启https我们需要把域名的nameserver改成他们的。 3.13补充又看了看 zeit 是支持ANAME/CNAME接入的，添加域名后把域名指向他们提供的*.now.sh即可，这样就很方便了。 (adsbygoogle = window.adsbygoogle || []).push({}); ping测试 查看详细结果 网站打开时间其实这样看上去效果还不如coding部署的页面，另外我测试了一下百度爬虫抓取，使用zeit的话是可以成功抓取的。 百度爬虫测试特别注意！如果你采取的是下载html文件验证的话，需要把html文件放到source文件夹里面，还得编辑一下文件内容，加上如下字段来避免hexo的模板改写该文件。 1234title: date: 2020-03-013 13:30:30layout: false--- 部署之后再验证，通过。 验证成功了，但是在之后的抓取诊断测试中试了很多次依旧是失败，仔细看报错，发现百度的爬虫访问的还是github的ip，依旧403… 截至发文，抓取测试依旧是异常的，不知道为什么dnspod中把境内/百度的连接都解析到了coding page上，但是还是没起作用，可能是还需要等一段时间生效吧。 3.13晚上更新，在我让默认流量都走coding page，境外流量都走github page后，百度爬虫终于成功抓取了页面，之前单独设置百度走coding page的时候一直失败，不知道是不是dnspod的解析出了点问题。 修改配置之后，再测(晚上九点)我目前用的配置是: (欢迎交流你们的配置) 电信——coding page 移动——coding page 联通——zeit的gcp 搜索引擎——coding 境外——github page 总结对比了三种方案，如果直接使用github page或者github page + cloudflare的话除了访问较慢，还有一个比较大的问题是百度爬虫无法爬取你的页面，自然文章都不会被百度收录。采用github page + coding page的方式，如果你能接受实名的话可以使用，但是coding的服务器也是在新加坡而不是国内，所以速度也不会有什么保证(不过我看电信去程是cn2，但是晚上丢包吓人)，这样做也可以被百度收录。而zeit的话部署非常方便，百度爬虫可以正常获取页面，速度也还算可以(使用前面两种方案时，移动的访问速度简直比蜗牛还慢，甚至干脆无法访问)，但是免费版每个月只有20G流量(不过对于访问量不大的个人博客已经够了)。 (adsbygoogle = window.adsbygoogle || []).push({});","link":"/posts/hexo-deploy-pages.html"},{"title":"docker中无法使用systemctl","text":"Ubuntu docker中无法使用systemctl当我在系统为Ubuntu18.04的服务器上尝试pull一个ubuntu或者debian的容器并运行的时候，在容器中尝试使用 systemctl命令，结果出现了System has not been booted with systemd as init system (PID 1). Can’t operat的报错，意思是init的进程号为1的进程（其实init根本没运行）。 对于centos镜像，我们可以在启动容器的时候设置第一条命令为 docker run -tid --name centos01 --privileged=true centos8 /usr/sbin/init，之前网上有提到对于debian/ubuntu可以使用docker run -tid --name ubuntu01 --privileged=true ubuntu:18.04 /sbin/init的命令来启动，不过实测，当前版本的镜像已经不行了，会出现docker: Error response from daemon: OCI runtime create failed: container_linux.go:344: starting container process caused “exec: &quot;/sbin/init&quot;: stat /sbin/init: no such file or directory”: unknown的报错，因为新的debian和ubuntu镜像中移除了init软件包，如果我们还想在debian/ubuntu的docker容器中使用systemctl命令，我们需要修改官方镜像。 创建一个Dockerfile: 123456789101112131415nano Dockerfile#填入以下内容并保存FROM ubuntu:18.04RUN apt-get update &amp;&amp; apt-get install -y init &amp;&amp; apt-get clean all#另外我还希望创建的镜像能够安装ssh并允许密码登录RUN apt-get update &amp;&amp; apt-get install -y openssh-server nano lsofRUN mkdir /var/run/sshdRUN echo 'root:password' | chpasswdRUN sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_configRUN /usr/sbin/sshd -D &amp;EXPOSE 22#构建镜像docker build -f ./Dockerfile . -t aoyouer/ubuntu#启动容器docker run -tid --name ub -p 2222:22 --privileged=true aoyouer/ubuntu /sbin/init 之后发现在容器中可以使用systemctl了，并且可以直接使用ssh服务了。 参考https://juejin.im/post/5d4007a3f265da03e5230fc6 https://docs.docker.com/engine/examples/running_ssh_service/ http://www.hxstrive.com/article/651.htm","link":"/posts/docker-systemctl.html"},{"title":"hexo使用valine评论并支持邮件通知","text":"使用valine评论并启用邮件通知使用hexo来生成静态页面做博客有很多好处，其中一个非常大的好处就是不需要使用自己的服务器省了一大笔钱。但是正是因为是静态网页也有一些不足的地方，例如评论。hexo的评论只能使用第三方的服务，如gitalk使用了github issues来储存评论，而valine使用了leancloud来部署一个后端并储存评论。之前一直使用的是gitalk，但是不是每个人都有github账号，而本主题的作者removeif正好这些天为主题添加了valine的最新评论支持。为了更加方便大家评论，我也决定尝试一下使用valine作为评论插件。 (adsbygoogle = window.adsbygoogle || []).push({}); 部署valine评论首先我们要让原版的valine评论正常运行，教程可以查看https://valine.js.org/quickstart.html。 之后因为主题支持，我只需要填上appid和appkey即可。 使valine支持评论邮件通知原版的valine有个很大的问题，那就是回复了评论之后，之前的评论者无法收到通知…那么评论就失去了意义，因为基本不会有人多次访问一个页面去查看评论是否得到了回复。而valine-admin这个项目增强了valine的功能，给valine增加了smtp服务支持，评论后台管理等功能。 选择云引擎——部署——从git源码部署，然后使用https://github.com/DesertsP/Valine-Admin作为代码库，并在该页面设置好环境变量，有一些必填的变量，如下表。我由于网站使用了根域名，并且使用了cname接入cloudflare，所以没办法再设置mx记录了，所以我没有再用域名邮箱，而失去mail.ru注册了一个邮箱(mail.ru支持域名邮箱，如果之后要换的话也方便) 变量 示例 说明 SITE_NAME Deserts [必填]博客名称 SITE_URL https://deserts.io [必填]首页地址 SMTP_SERVICE QQ [新版支持]邮件服务提供商，支持 QQ、163、126、Gmail 以及 更多 SMTP_USER xxxxxx@qq.com [必填]SMTP登录用户 SMTP_PASS ccxxxxxxxxch [必填]SMTP登录密码（QQ邮箱需要获取独立密码） SENDER_NAME Deserts [必填]发件人 SENDER_EMAIL xxxxxx@qq.com [必填]发件邮箱 ADMIN_URL https://xxx.leanapp.cn/ [建议]Web主机二级域名，用于自动唤醒 BLOGGER_EMAIL xxxxx@gmail.com [可选]博主通知收件地址，默认使用SENDER_EMAIL AKISMET_KEY xxxxxxxxxxxx [可选]Akismet Key 用于垃圾评论检测，设为MANUAL_REVIEW开启人工审核，留空不使用反垃圾 配置好环境变量之后便可以重启/启动容器了。 前往我们之前设置好的web主机域名下设置一个管理员账号 如我的 notesail.avosapps.us/sign-up 记得环境变量也要改 然后由于valine免费版的休眠规则 免费版的 LeanCloud 容器，是有强制性休眠策略的，不能 24 小时运行： 每天必须休眠 6 个小时 30 分钟内没有外部请求，则休眠。 休眠后如果有新的外部请求实例则马上启动（但激活时此次发送邮件会失败）。 所以我们需要添加两个定时器 一个为0 0/30 7-23 * * ?的self_wake规则，即每20分钟醒来一次 另一个为0 0 8 * * ?的resend规则，即每天早上八点补发一次邮件。 之后再重启一次引擎，大功告成，发邮件测试一下吧。 现在用户不需要登陆也能留下评论啦，但是此类评论有个不好的地方就是如果有人乱填邮箱就容易造成一些尴尬的情况，所以还是希望大家都自觉别乱填邮箱。","link":"/posts/valine-admin.html"},{"title":"Hello Hexo","text":"我的hexo使用笔记(不定期更新)主题主题使用了removeif修改后的icarus，之前看到了icarus就很喜欢它的设计，但是总有一些不太尽如人意的地方，自己又没有特别多的时间去一一修改，当看到removeif修改后的icarus(amazing)主题，只感觉到相见恨晚。 永久链接hexo原版的固定链接实在是太长了，我一开始采取的修改措施是改成了:categories/:title/的形式，并使用中文转拼音的插件，但是这样的话如果使用hexo new的时候输入的是中文名，生成的链接往往极其冗长也并不好看，所以我才去了网上的方案，如果输入的是英文名然后修改title为中文的方案虽然可以自定义链接，但是文章多了也不好管理，所以最终我采取了将hexo目录下的_config配置中的permalink改为了 posts/:urlname 的形式，并修改scaffold中的post.md，给模板也加上该字段，之后hexo生成链接时使用的名字就是我们自己写在urlname的值了，然后我们便可以直接在hexo new的时候使用中文了。 百度收录比起谷歌收录，百度收录较为麻烦，我采取了双部署的方式，在coding page上也部署了一份，并且通过dnspod将搜索引擎的访问解析到了coding page上，当前国内大部分网络访问也是解析到coding page上的，感觉会快一些。 为amazing主题添加widget我为该主题添加了一个widget用于显示访客所在的地方,即 revolvermaps.com的统计js。假设该widget命名为global 首先添加widget的json文件12345678910111213141516nano themes/amazing/include/schema/widget/global.json{ \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"$id\": \"/widget/global.json\", \"description\": \"Table of contents widget configurations\", \"type\": \"object\", \"properties\": { \"type\": { \"type\": \"string\", \"const\": \"global\" } }, \"required\": [ \"type\" ]} 在widget.json里面添加该widget12345nano themes/amazing/include/schema/common/widgets.json//添加上 { \"$ref\": \"/widget/global.json\" } 创建该widget的模板文件123456789101112131415161718192021222324nano themes/amazing/layout/widget/global.jsxconst { Component } = require('inferno');const { cacheComponent } = require('../util/cache');class Global extends Component { render() { return &lt;div class=\"card widget\"&gt; &lt;div class=\"card-content\"&gt; &lt;div class=\"menu\"&gt; &lt;h3 class=\"menu-label\"&gt;网站访客&lt;/h3&gt;&lt;script type=\"text/javascript\" src=\"//rf.revolvermaps.com/0/0/8.js?i=l&amp;amp;m=0&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=33\" async=\"async\"&gt;&lt;/script&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;; }}module.exports = cacheComponent(Global, 'widget.global', props =&gt; { const { helper, widget } = props; return { buttonTitle: helper.__('widget.global') };}); 最后在_config.yml里面加上 1234'position: righttype: global' 即可","link":"/posts/hello-hexo.html"},{"title":"kvm单网卡桥接模式","text":"Ubuntu18 kvm单网卡桥接家里有一台nuc8作为服务器使用，平时都是使用ubuntu18，但是由于某项服务在linux下运行出现异常，而经过朋友的测试，在windows下可以正常运行，于是我考虑使用kvm在Linux上虚拟化一个windows server来使用。安装相关程序的教程网上有很多也比较简单，这里就不赘述了，但是在装好程序之后，我试了很多种方法才最终配置好了虚拟机的桥接，所以写下这篇文章记录一下。 系统中添加网桥 libvirt中添加网桥 修改虚拟机网络配置 参考 下面的操作可能会导致网络中断，远程连接断开，能直接在宿主机上连接显示器操作是最方便的了 系统中添加网桥ubuntu18的网络接口使用netplan来管理，配置文件位于/etc/netplan/下，以我的为例。nano /etc/netplan/01-network-manager-all.yaml。 1234567891011121314151617network: ethernets: eno1: dhcp4: no bridges: br0: interfaces: [eno1] dhcp4: no addresses: [192.168.0.100/24] gateway4: 192.168.0.1 parameters: stp: true forward-delay: 4 nameservers: addresses: [192.168.0.1] version: 2 注意到这里需要把物理网卡eno1的dhcp关掉(我之前也没使用dhcp，而是使用静态ip192.168.0.100)，改用在br0网桥将ip设置成之前物理网卡的静态ip 192.168.0.100，当然，在这也可以使用dhcp。 然后使用netplan apply命令，之后使用ifconfig查看网卡信息，我们可以看到物理网卡上已经没有ip了，而多出了一个叫br0的网络设备，ip就是我们指定的192.168.0.100，之后我们在网络中依旧可以用192.168.0.100访问该服务器。 libvirt中添加网桥虽然在系统中添加了网桥，但是此时在virt-manager中是看不到我们添加的网桥的，还需要在virsh中添加一个网桥配置。 新建一个名为bridge.xml的文件，编辑如下。 12345&lt;network&gt; &lt;name&gt;kvm-bridge&lt;/name&gt; &lt;forward mode=\"bridge\"/&gt; &lt;bridge name=\"br0\"/&gt;&lt;/network&gt; 然后执行下列命令来加载该配置文件。 123virsh net-define bridge.xmlvirsh net-start kvm-bridgevirsh net-autostart kvm-bridge 之后执行virsh net-list --all即可看到我们添加的libvirt网桥了。 修改虚拟机网络配置这里我直接使用了virt-manager图形化管理工具，修改虚拟机的网络设备，注意到此时已经可以直接看到kvm-bridge网络了。 之后开启kvm虚拟机，理论上就可以分配到192.168.0.1/24上的ip了，如果没有的话可以去适配器选项里面手动指定ip。 参考https://fabianlee.org/2019/04/01/kvm-creating-a-bridged-network-with-netplan-on-ubuntu-bionic/ (adsbygoogle = window.adsbygoogle || []).push({});","link":"/posts/kvm-bridge.html"},{"title":"在Linux上运行bdx(BedrockX)开设基岩版MC插件服","text":"BedrockX 开设基岩版插件服 在windows上生成服务端程序 安装wine5.0 安装C++运行库 开始运行bdx 参考 bds的推出使得基岩版终于能够开设私人专用服务器，但是由于mojang并不重视服务端的开发，在bds推出一年多以后服务端依旧是bug多多，且不提供插件api，不具有行为包的完整特性，看上去就像是一个半成品。(虽然官方也说了这就是alpha版本)这也给多人服务器的开设造成了巨大的不方便，比如无法传送到他人的位置，无法使用领地保护*(曾经我们都是用命令方块来圈地的)*，无法反作弊等等。虽然官方推出的服务端就是个半成品，但是一年多来各位大佬为更好的开服体验做出了诸多的贡献，比如之前的Codehz的StoneServer，Sysca11的bdlauncher等等作品都在原版bds的基础上提供了api，Codehz的StoneServer扩展了官方的脚本api(在官方将其从bds中国移除之后Codehz还自己将api加了进去)使得用js制作服务端插件成为可能，而Sysca11在他的bdlauncher基础上还做出了圈地/传送/经济等各种插件...这些在一开始都是难以想象的，bds服能有今天那么丰富的内容首先得感谢诸位开发者的贡献。 随着时间的发展，支持插件的服务端也在变化，Stoneserver很可惜的停更了，但是Codehz在最近推出了全新的Element Zero，而bdl也发展成了bdx。这两者和之前的服务端的一个巨大的差异就是，他们都是基于windows版本的bds，据说在性能上相对linux的bds会有很大的提升，并且可以在windows server上使用了，linux也依旧可以通过wine来使用。这篇文章介绍如何在Linux上使用bdx，如果要在windows上使用的话则可以参考 https://www.jianshu.com/p/e1ccd0f96fd6 。 bdx项目地址 本机环境 Windows10 Ubuntu1804 （因为bdx需要在wine5.0以上运行，推荐直接使用1904以上的系统。） 在windows上生成服务端程序据作者所说 注意：RoDB.exe在wine环境似乎工作不正常，请用相同pdb在windows下生成symdb，再复制过来 所以我们现在windows上运行程序，生成所需要的资源，在成功运行bdx之后再打包放到我们的linux服务器上。 新建一个文件夹(我这里就叫bdx了)，从官网下载windows 版本的服务端压缩包放进去，然后从项目页面下载base_env.7z、release_dbg_x.7z两个文件放到该文件夹下。 解压三个文件夹，然后将得到的base_env和release_xx两个文件夹中的文件都移动到得到的两个文件夹外(bdx文件夹中)。运行 RoDB.exe,如果bedrock_server.symdb和bedrock_server.symdef两个文件生成的话就可以了。之后双击运行bedrock_server.exe，如果显示如下，就算成功在windows上配置运行了。 如果你是windows开服到这里就足够了，不过要是你想用linux开服就还要多做几步。 使用zip将整个bdx文件夹压缩，并使用sftp之类的方式传送到服务器上。 (adsbygoogle = window.adsbygoogle || []).push({}); 安装wine5.0bdx需要在wine5.0以上的环境运行，不然会出错。可惜大部分源中的wine都是3.0左右的版本。所以我们还需要添加源并安装wine5.0。以ubuntu为例(下面的方法1604~1910都可用)。此处参考了ubuntuhandbook的教程. 1904以下的版本ubuntu1904以下的版本如果直接安装会遇到很多依赖无法解决的问题，所以请首先安装下列依赖。 1&gt;sudo apt-get install libgnutls30:i386 libldap-2.4-2:i386 libgpg-error0:i386 libxml2:i386 libasound2-plugins:i386 libsdl2-2.0-0:i386 libfreetype6:i386 libdbus-1-3:i386 libsqlite3-0:i386 龟速下载警告！！ 下面这些操作使用了国外的软件源，如果你的服务器在国内，大概率在下载时遇到速度基本没有的情况(得下载几百MB的文件)，所以强烈建议使用代理。 在服务器上运行代理软件之后，假设在1080端口开启了socks5代理，那么在使用apt命令的时候只需要使用 sudo apt-get -o Acquire::http::proxy=”socks5h://127.0.0.1:1080/“ update 这样的形式即可。 1234567sudo dpkg --add-architecture i386wget -nc https://dl.winehq.org/wine-builds/winehq.key; sudo apt-key add winehq.key# 下面的eoan请修改成和系统对应的代号 如 ubuntu1804 改成 bionic ubuntu 1604改成 xenialsudo apt-add-repository 'deb https://dl.winehq.org/wine-builds/ubuntu/ eoan main'sudo add-apt-repository ppa:cybermax-dexter/sdl2-backport# 最后开始安装wine5.0sudo apt update &amp;&amp; sudo apt install --install-recommends winehq-stable (adsbygoogle = window.adsbygoogle || []).push({}); 如果网络够好的话很快就能装上，网络不好的话…一天都装不上。安装完毕之后使用wine –version，显示5.0即可。我在另一台服务器上遇到了缺少libfdk-aac库的情况，前往https://ubuntu.pkgs.org/18.04/ubuntu-multiverse-i386/libfdk-aac1_0.1.5-1_i386.deb.html下载amd64和i386版本的deb包手动使用dpkg -i 安装之后即可 安装C++运行库这一步需要有图形界面的操作，你可以在linux服务器上安装图形界面并使用vnc进行下面的操作，也可以使用xshell+xmanager的方式来安装,推荐使用后者(不需要额外安装图形界面)。 在服务器上执行(vnc图形界面中执行或者xshell中执行) 12wget https://download.visualstudio.microsoft.com/download/pr/8c211be1-c537-4402-82e7-a8fb5ee05e8a/B6C82087A2C443DB859FDBEAAE7F46244D06C3F2A7F71C35E50358066253DE52/VC_redist.x64.exewine VC_redist.x64.exe 开始运行bdx将之前的bdx压缩包上传到服务器上并解压后，进到bdx文件夹中，使用wine bedrock_server.exe即可开启bdx服务端了。 如果觉得大量的DEBUG信息太碍眼的话可以使用export WINEDEBUG=-all隐藏DEBUG信息输出。 参考 安装wine5.0 windows运行bdx bdx项目的介绍 (adsbygoogle = window.adsbygoogle || []).push({});","link":"/posts/linux-bedrockx.html"},{"title":"nodejs学习记录","text":"node学习实践npmnpm是node的包管理工具，我们可以使用npm来安装依赖，也可以将自己编写好的程序上传到npm库中供他人使用。 参考链接 https://www.runoob.com/nodejs/nodejs-npm.html 安装模块我们可以使用npm install来安装npm模块，此时安装路径为当前目录下的node_modules文件夹,如果带上了-g参数，将进行全局安装，安装到 /usr/local 或 node 的安装目录，此时在其它的项目中也可以使用该模块。 创建模块其他命令 使用npm uninstall来卸载模块 使用npm update更新模块 使用npm search搜索模块 typescript TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。 TypeScript 由微软开发的自由和开源的编程语言。 TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。 TypeScript 是一种给 JavaScript 添加特性的语言扩展。增加的功能包括： 类型批注和编译时类型检查 类型推断 类型擦除 接口 枚举 Mixin 泛型编程 名字空间 元组 Await 以下功能是从 ECMA 2015 反向移植而来： 类 模块 lambda 函数的箭头语法 可选参数以及默认参数 TypeScript 可以通过类型注解提供编译时的静态类型检查，另外tsc可以将多个ts文件编译成一个js文件，于是我们可以将代码分散到多个文件中，条理更清晰，之后的学习实践都将使用Typescript来进行。 Typescript环境配置我们首先要安装Typescript的环境，使用npm install -g typescript即可，成功安装之后我们便可使用tsc来进行Typescript相关的操作。比如编写hello.ts let say:string = &quot;hello world&quot;; console.log(say);`&lt;/pre&gt; 使用`tsc hello.ts`将该文件编译为js文件，同一个目录下出现了名为hello.js的文件，使用`node hello.js`即可执行。 ### Typescript学习笔记 关于Typescript的详细教程请查看[Typescript中文文档](https://www.tslang.cn/docs/home.html)以及[菜鸟教程Typescript](https://www.runoob.com/typescript/ts-basic-syntax.html) #### 面向对象 ts是面向对象的语言 &gt; * **对象**：对象是类的一个实例，有状态和行为。 类：类是一个模板，它描述一类对象的行为和状态。 方法：方法是类的操作的实现步骤。 以下操作创建了一个类以及实例化了它的一个对象,并调用了对象的一个方法 &lt;pre&gt;`class Friend { greet():void { console.log(&quot;hello!&quot;) } } var friend = new Friend(); friend.greet();`&lt;/pre&gt; 编译成的js文件内容如下 &lt;pre&gt;`var Friend = /** @class */ (function () { function Friend() { } Friend.prototype.greet = function () { console.log(&quot;hello!&quot;); }; return Friend; }()); var friend = new Friend(); friend.greet(); `&lt;/pre&gt; #### 基础类型 Typescript声明一个变量的时候，可以规定该变量的类型，格式`let a: number = 1;` any 此类型的变量可以赋予任何类型的值(编译时不会进行类型检查) `let arrayList: any[] = [1, false, 'fine']; //可以定义一个可以储存任何类型的数组` number: ts中没有整数类型以及浮点数类型，而都是使用number类型 string 字符串类型 boolean 布尔类型 数组类型采用如下格式声明 `// 在元素类型后面加上[] let arr: number[] = [1, 2]; // 或者使用数组泛型 let arr: Array = [1, 2];` 元组 `let x: [string, number]; x = ['Runoob', 1]; // 运行正常 x = [1, 'Runoob']; // 报错 console.log(x[0]); // 输出 Runoob` 枚举 `enum Color {Red, Green, Blue}; let c: Color = Color.Blue; console.log(c); // 输出 2` void 用于标识方法返回值 function hello(): void{} null 表示对象缺失，null依旧是一个object(不同于undefined) undefined 用于将变量初始化为一个未定义的值 never 是其它类型的子类型，代表永远不会出现的值 可以使用”|“来表示一个变量可以是多种类型，如let x: number | null | undefined; 类型断言，可以使用或者是value as string的方式来告诉编译器一个变量的类型。 Null 和 Undefined 是其他任何类型（包括 void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。而在TypeScript中启用严格的空校验（–strictNullChecks）特性，就可以使得null 和 undefined 只能被赋值给 void 或本身对应的类型 变量声明在较新的标准中加入了let和const两种变量声明方式 let在ES6之前，我们都是用var来声明变量，而JS只有函数作用域和全局作用域，没有块级作用域，所以{}限定不了var声明变量的访问范围，新加入的let可以将变量的作用域限定在代码块中，并且无法在变量声明前使用该变量（如果使用var，该变量的声明会被提升到使用前），相同代码块中，同名变量不能多次声明，相对于var，let提升了安全性。 const使用const修饰的变量拥有与let类似的作用域规则，除此之外它在被赋值后无法再次改变。 解构 数组解构 `let input = [1, 2]; let [first, second] = input; console.log(first); // outputs 1 console.log(second); // outputs 2` `// swap variables [first, second] = [second, first];` 使用…来获得剩余的变量 `let [first, ...rest] = [1, 2, 3, 4]; console.log(first); // outputs 1 console.log(rest); // outputs [ 2, 3, 4 ]` 对象解构 `let o = { a: \"foo\", b: 12, c: \"bar\" }; let { a, b } = o;` 若使用…获得剩余变量，解构出来的也是一个对象。 `//属性重命名 此处:不是用来指定类型 let { a: newName1, b: newName2 } = o;` 函数解构知道有这么个东西就好… 接口注意，ts可以以下面这种方式直接创建一个对象(不需要使用类) let myObj = { size: 10, label: &quot;Size 10 Object&quot; };,接口中可以描述属性以及方法。 示例: `interface LabelledValue { label: string; } function printLabel(labelledObj: LabelledValue) { console.log(labelledObj.label); } let myObj = {size: 10, label: \"Size 10 Object\"}; printLabel(myObj);` 可选属性接口里的属性可以不是必须的，在变量名后使用 ?: 来指定接口中的可选属性 只读属性在变量名之前加上readonly来指定只读属性，只读属性只能在对象创建的时候修改其值，另外可以使用ReadonlyArray创建只读数组，此类数组创建后不可修改值，无法赋值给普通数组(可以使用类型断言 ra as number[] 来转换) 额外属性检查如果直接传递对象，对象可以带有接口不存在的字段，但是如果传递的是对象字面量如 let mySquare = createSquare({ colour: &quot;red&quot;, width: 100 });会报错，可以使用类型断言绕开检测，或者添加字符串索引签名，在接口中加入[propName: string]: any;,表示该接口还可以有任意数量的属性。 函数接口指定参数类型以及返回值类型 `interface SearchFunc { (source: string, subString: string): boolean; }` 索引类型索引可以是数字或者字符串，当使用数字索引的时候实际上ts是将数字转换为字符串之后再索引对象,因此数字索引时返回的对象必须是字符串索引返回对象的子类。 `interface StringArray { }` `interface ReadonlyStringArray { readonly [index: number]: string; } let myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"]; myArray[2] = \"Mallory\"; // error!` 接口继承可使用extends进行继承，一个接口可以继承多个接口 `interface Shape { color: string; } interface PenStroke { penWidth: number; } interface Square extends Shape, PenStroke { sideLength: number; } let square = {}; square.color = \"blue\"; square.sideLength = 10; square.penWidth = 5.0;` 类示例 `class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return \"Hello, \" + this.greeting; } } let greeter = new Greeter(\"world\");` 类可以使用继承，另外注意派生类如果有构造函数constructor，需要调用super(),继承之后方法可以重写，另外也可以使用多态，父类引用子类对象，最终调用方法时使用的还是子类的方法。 访问修饰符Typescript中的对象成员也有 public(默认，可不写)/private/protect 这几个访问修饰符，和java类似，private修饰的成员不能在类之外访问（子类也不行）而protect修饰的成员可以在子类中访问。 若一个类的构造函数被标记为protect，该类不能被实例化，但是可以被继承，子类可以实例化。 另外，可以使用readonly将成员属性设置为只读的，只读属性只能在声明时或者构造函数中赋值。 还可以使用参数属性，定义与赋值在同一个地方进行 TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。 然而，当我们比较带有 `private`或 `protected`成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 `private`成员，那么只有当另外一个类型中也存在这样一个 `private`成员， 并且它们都是**来自同一处声明**时，我们才认为这两个类型是兼容的。 对于 `protected`成员也使用这个规则。 &lt;pre&gt;`class Animal { private name: string; constructor(theName: string) { this.name = theName; } } class Rhino extends Animal { constructor() { super(&quot;Rhino&quot;); } } class Employee { private name: string; constructor(theName: string) { this.name = theName; } } let animal = new Animal(&quot;Goat&quot;); let rhino = new Rhino(); let employee = new Employee(&quot;Bob&quot;); animal = rhino; //兼容，name来源相同 animal = employee; // 错误: Animal 与 Employee 不兼容. 如果是public修饰的即认为兼容`&lt;/pre&gt; 存取器注意存取器需要编译目标版本大等于于ES5 ts的getter/setter和java不太一样，比如 ` private _fullName: string; get fullName(): string { return this._fullName; } //之后调用get方法是用 object.fullname的方式来执行的。` 静态属性Typescript中也可以使用static修饰静态属性 抽象类可以使用abstract修饰抽象类，是用abstract修饰抽象类中的抽象方法，抽象方法不包含方法体，由派生类实现。抽象类不可实例化，抽象类引用的子类对象不可调用子类特有的方法。 函数有名字的函数以及匿名函数`function add(x: number, y: number): number { return x + y; } let myAdd = function(x: number, y: number): number { return x + y; };` 可选参数以及默认参数默认情况下，参数的数量是必须满足函数的要求如果需要设置可选参数我们需要使用 ?: 来指定一个可选参数，没有传递这个参数的时候，形参值为undefined,可选参数必须跟在必须参数的后面 function buildName(firstName: string, lastName?: string) 除此之外，我们也可以设置参数的默认值，设置了默认值的参数如果用户没有传递有效值时，会使用默认值 function buildName(firstName: string, lastName = &quot;Smith&quot;) 剩余参数若我们无法预料会有多少个参数传入的时候可以使用剩余参数 剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ ...）后面给定的名字，你可以在函数体内使用这个数组。 `function buildName(firstName: string, ...restOfName: string[]) { return firstName + \" \" + restOfName.join(\" \"); }` 重载参数类型不同，数量不同，类型的顺序不同 泛型有时间时需要继续深入了解 `function identity(arg: T): T { return arg; }` 类型变量T记录了传入的变量的类型，返回的也是已知类型的变量而非any 使用时有下面两种方式 手动指定或者是用类型推论 `let output = identity(\"myString\"); // type of output will be 'string' //某些复杂情况可能无法使用下面这种形式，需要手动指定类型 let output = identity(\"myString\"); // type of output will be 'string'` 命名空间如果要在外部调用命名空间中的类/接口，需要加上export关键字 `namespace SomeNameSpaceName { export interface ISomeInterfaceName { } export class SomeClassName { } }` 在外部调用 `SomeNameSpaceName.SomeClassName;` 如果命名空间在另一ts文件中，需要使用三斜杠语法 /// &lt;reference path = &quot;SomeFileName.ts&quot; /&gt; 模块`// 模块导出部分 // 文件名 : SomeInterface.ts export interface SomeInterface { // 代码部分 }` `// 需要使用模块时进行导入 import someInterfaceRef = require(\"./SomeInterface\");` Typescript中还有许多的高级用法我还没有学习，在将来的学习中还需要返回来深入了解。 使用Typescript创建一个nodejs项目实际使用Typescript时，我们就不像上面那样直接使用tsc命令并带上一系列参数来编译ts文件，这是我们需要一个名为tsconfig.json的Typescript编译配置文件。 项目目录结构如下 ├─build├─node_modules│ ├─.bin│ ├─@types│ │ └─node│ │ └─ts3.2│ ├─http│ └─typescript└─src 在项目根目录下执行 tsc --init 将会生成tsconfig.json文件，文件里面的配置项有很多，我们只修改其中的几项。 `{ \"compilerOptions\": { \"target\": \"es6\", /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019' or 'ESNEXT'. */ \"module\": \"commonjs\", /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */ \"outDir\": \"./build\", /* Redirect output structure to the directory. */ \"rootDir\": \"./src\", /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */ \"strict\": true, /* Enable all strict type-checking options. */ \"noImplicitAny\": false, /* Raise error on expressions and */ \"esModuleInterop\": true /* Enables emit interoperability between */ } }` 保存配置文件之后，我们只需要在项目根目录输入tsc，就可以将src文件夹中的ts文件编译，产生的js文件会储存在build文件夹中。 使用.d.ts文件我们在项目中常常需要用到内建模块或者第三方模块，但是在.ts文件中是没办法直接导入模块的。 我们可以在项目目录下执行npm install --save-dev @types/node获得node的类型说明文件，但是这个方法只能解决内建模块的说明文件问题，对于第三方模块 http://microsoft.github.io/TypeSearch/ 我们可以修改package.json ` \"scripts\": { \"build\": \"tsc\" } 之后我们只需要使用npm run build即可执行tsc命令（当然在将来的应用中我们往往不是只执行这一条简单的命令），比如可以加入&quot;dev&quot;: &quot;supervisor -w build ./build/server.js&quot;之后执行npm run dev来持续监控脚本，在js文件变化后重启服务器。 node","link":"/posts/study-nodejs.html"},{"title":"使用Babylon.js在网页上显示glb模型","text":"使用Babylon.js在网页上显示glb模型Minecraft的结构方块可以导出格式为 .glb 的模型文件，今天突发奇想，“能不能把这些模型放到网页上展示呢?”经过一番搜索，最终使用 Babylon.js Viewer 实现了这个功能。 模型文件关于各种模型文件格式的介绍可以查看下面两个网页: 三维文件格式知多少 | abc、glTF、fbx、obj、dae、stl、3ds… 什么是3D模型，什么是GLTF，又如何使用GLTF文件 关于glb格式的介绍 GLTF文件实际上不是单个文件。相反，它们是包含JSON文档的文件夹，然后还有一些图片，以及其他包含几何图形，纹理，凹凸贴图等的文件夹。其他文件夹都是通过一个相对URLS进行引用，因此你一般可以将文件夹转储到Web服务器上，直接引用GLTF文件，其余资源将正确加载。 但如果你使用的是CDN而非自己的Web服务器，则可能无法控制相对URL，而且它们会出现问题。相反，你可以将GLTF转换为名为GLB的二进制格式，一个包含所有资源的单个文件。然后，这个单个文件可以放在你的CDN上并直接引用。 要获取GLB文件，你可以直接从3D建模程序中导出它们，也可以使用工具将GLTF转换为GLB。你可以使用这个非常好的基于网络的转换器：MakeGLB。只需将包含GLTF文件的文件夹拖到页面，然后它就会生成并下载GLB文件。接下来将GLB文件上传到Glitch项目的Assets部分。然后选择asset的URL并在主文档中予以引用。 Babylon.jsBabylon.js是一个基于webgl的3d图形引擎，利用他我们可以在网页上渲染出3D图形，而Babylon.js可以让我们很简单的在网页上展示我们的模型，支持glb格式。参考Babylon.js viewer的文档，我们可以在网页上使用下面这种方式插入一个viewer来展示模型。 123456789&lt;html&gt;&lt;head&gt; &lt;title&gt;Babylon.js Viewer - Display a 3D model&lt;/title&gt; &lt;script src=\"https://preview.babylonjs.com/viewer/babylon.viewer.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;babylon model=\"https://models.babylonjs.com/boombox.glb\" templates.main.params.fill-screen=\"true\"&gt;&lt;/babylon&gt;&lt;/body&gt;&lt;/html&gt; 如果想在wordpress中使用，直接使用 12&lt;script src=\"https://cdn.babylonjs.com/viewer/babylon.viewer.js\"&gt;&lt;/script&gt; &lt;babylon model=\"https://models.babylonjs.com/boombox.glb\" templates.main.params.fill-screen=\"true\"&gt;&lt;/babylon&gt; 由于babylon.js的js文件都储存在国外的服务器且文件较大，所以有时候加载相当缓慢，可以考虑使用CDN或者把js文件下载到本地…另外我的glb模型文件放在阿里云oss上，这里还遇到了跨域的问题，这个另外开一篇文章了记录了。至于最终效果如何，可以查看下图:","link":"/posts/babylon-glb.html"},{"title":"如何使用bdl插件","text":"(adsbygoogle = window.adsbygoogle || []).push({}); bdl插件使用bdl项目地址 https://github.com/BDLDev/bdlauncher 本文中大部分内容来源于此[adinserter block=”1”] GUI菜单输入/c即可打开菜单，在这里可以进行便捷操作。 传送 指令 功能 /home add [名字] 添加一个家 /home del [名字] 删除一个家 /home ls 查看你所有的家 /home go [名字] 回家 /warp ls 查看所有warp点 /warp [名字] 传送到指定warp点 /warp add [名字] 添加点（需要OP） /warp del [名字] 删除一个点（需要OP） 玩家ID可以模糊匹配，例如AbCde 可以只输入ab 指令 功能 /tpa f [玩家ID] 让玩家传送到你 /tpa t [玩家ID] 你到玩家 /tpa ac 同意 /tpa de 拒绝 /suicide 自杀 新版本GUI指令: 指令 功能 /home gui GUI回家 /warp gui GUI Warp /tpa gui GUI传送 经济服务器目前未采用经济系统，但是圈地依旧需要钱，直接问管理员要即可 指令 功能 /money query 查钱 /money query [玩家名] 查询目标玩家的金钱 /money pay [玩家ID] [钱数] 玩家间转账(单次最大10000) /money paygui 使用GUI来转账 #### OP命令 指令 功能 - - /money set [玩家ID] [钱数] 将玩家的金钱设置为指定值 /money add [玩家ID] [钱数] 为玩家增加一些金钱 /money rd [玩家ID] [钱数] 扣钱，如果扣钱成功，会触发success，可以做链式命令方块或者cmdchain内cond使用 /reload_money 重载配置 领地命令 指令 功能 /reload_land 重载配置 /land a 进入起点模式,点地选点 /land b 进入终点模式，点地选点 /land exit 退出选点模式 /land buy 选点之后买地 /land trust [玩家ID] 添加主人 /land trustgui GUI添加主人 /land untrust [玩家ID] 删除主人 /land untrustgui 删除主人GUI /land sell 卖地（op可以强行卖） /land query 查看当前领地主人 /land give [玩家ID] 转让权限注意，只有land的第一个owner拥有trust,untrust,sell,perm的权限，trust后的主人只有领地的其他权限。可以通过land give 转让全部权限给别人 /land perm 数字 指定领地具体权限 12345678 PERM_USE=2, 使用方块权限 PERM_ATK=4, 攻击权限 PERM_BUILD=8, 建造破坏权限 PERM_POPITEM=16, 物品展示框权限 PERM_INTERWITHACTOR=32 盔甲架等交互权限权限数字为可以使用的权限之和例如 2=可以睡觉，开箱子6=可以睡觉，开箱子，攻击生物 (adsbygoogle = window.adsbygoogle || []).push({});","link":"/posts/bdl-plugins-guide.html"},{"title":"一台电脑多个hexo站点的配置","text":"一台电脑多个hexo站点的部署方法 本文主要内容转载自 https://www.sugen.cn/article-20190622.html 我使用的系统是 Ubuntu 20.04 有时候我们需要在一台电脑上存放多个hexo的网站文件，这时候使用git来部署的时候就会遇到问题，因为第一次部署时会要求我们输入邮箱与密码，而在另一个站点文件夹中使用hexo d来部署的时候则会直接使用之前设置的那个邮箱与密码，并且我们是无法使用git带参数的方式来使用hexo d进行部署的，所以我们只能转而使用ssh key的方式来进行部署。 (adsbygoogle = window.adsbygoogle || []).push({}); 生成ssh key首先我们要使用ssh-keygen来为两个站点生成两个ssh密匙 12ssh-keygen -t rsa -b 4096 -C \"account1@example.com\"ssh-keygen -t rsa -b 4096 -C \"account2@example.com\" 开启ssh agent并添加密钥使用eval &quot;$(ssh-agent -s)&quot; 来启动ssh-agent （直接输入ssh-agent -s应该也没什么问题） 然后把私钥添加到ssh-agent中进行管理。 12ssh-add -K ~/.ssh/account1ssh-add -K ~/.ssh/account2 编辑ssh的配置文件，为git帐户设置别名 编辑ssh配置文件 （没有文件则新建） 我这里还有个coding page的别名配置 12345678910111213141516nano ~/.ssh/configHost account1.github.comHostName github.comUser gitIdentityFile ~/.ssh/account1Host account2.github.comHostName github.comUser gitIdentityFile ~/.ssh/account2Host notesail.coding.netHostName e.coding.netUser gitIdentityFile ~/.ssh/notesail 配置好之后可以使用ssh -T account1.github.com测试是否可以正常连接。 使用密钥部署hexo修改hexo的站点配置文件站点文件夹中的_config.yml，不是插件文件夹里的 123456deploy:- type: git repo: git@account1.github.com:username/username.github.io.git branch: master name: username email: example@gmail.com 之后再使用hexo d的时候便会使用该配置中的用户来进行部署，而不是环境变量中的git用户。 如果还是存在问题，先删除掉站点文件夹中的 .deploy_git 文件夹并再次部署.","link":"/posts/hexo-multi-sites.html"},{"title":"nginx访问日志记录cloudflare后真实ip","text":"accesslog记录真实ip官方方法使用nginx -V 2&gt;&amp;1 | grep with-http_realip_module，查看nginx是否包含http_realip_module模块，我的ubuntu18 apt安装的nginx已经带有该模块了，那么只需要前往 /etc/nginx/nginx.conf向http{}里面添加如下内容即可。https://support.cloudflare.com/hc/en-us/articles/200170786-Restoring-original-visitor-IPs-Logging-visitor-IP-addresses-with-mod-cloudflare- 123456789101112131415161718192021222324set_real_ip_from 103.21.244.0/22;set_real_ip_from 103.22.200.0/22;set_real_ip_from 103.31.4.0/22;set_real_ip_from 104.16.0.0/12;set_real_ip_from 108.162.192.0/18;set_real_ip_from 131.0.72.0/22;set_real_ip_from 141.101.64.0/18;set_real_ip_from 162.158.0.0/15;set_real_ip_from 172.64.0.0/13;set_real_ip_from 173.245.48.0/20;set_real_ip_from 188.114.96.0/20;set_real_ip_from 190.93.240.0/20;set_real_ip_from 197.234.240.0/22;set_real_ip_from 198.41.128.0/17;set_real_ip_from 2400:cb00::/32;set_real_ip_from 2606:4700::/32;set_real_ip_from 2803:f800::/32;set_real_ip_from 2405:b500::/32;set_real_ip_from 2405:8100::/32;set_real_ip_from 2c0f:f248::/32;set_real_ip_from 2a06:98c0::/29;use any of the following tworeal_ip_header CF-Connecting-IP; 然后重启nginx即可生效 方法二感觉该方法虽然能获取真实ip，但是会丢失一些数据… 方法来源于 https://www.yunloc.com/647.html 分析nginx的access.log访问日志的时候，如果我们使用了cloudflare cdn，我们会发现记录的ip都是cloudflare的节点ip，那么该如何记录真实的访问者ip呢？ nano /etc/nginx/nginx.conf修改nginx的配置文件，在http{}内加入 12345678map $HTTP_CF_CONNECTING_IP $clientRealIp { &quot;&quot; $remote_addr; ~^(?P&lt;firstAddr&gt;[a-z0-9.:]+),?.*$ $firstAddr;}log_format access '$clientRealIp [$time_local] &quot;$request&quot; ' '$status $body_bytes_sent &quot;$http_referer&quot; ' '$http_user_agent $remote_addr $request_time'; 再在同一文件下的 access_log 末尾加上 access 如 access_log /var/log/nginx/access.log access;. systemctl restart nginx生效即可。 (adsbygoogle = window.adsbygoogle || []).push({});","link":"/posts/cloudflare-realip.html"},{"title":"微信小程序使用npm模块","text":"小程序使用npm模块以及GB2312解码使用npm模块今天的一个项目中，小程序从服务器得到的数据是16进制数据包，形似CE C2 B6 C8 3A 32 37 20 43 2C CA AA B6 C8 3A 34 38 20 25 20 0D 0A,研究后发现这个数据包使用的是GB2312的编码，而javascript是没办法直接解码GB2312的，于是我们需要使用npm导入第三方包了，期间遇到了一些坑。 首先先在小程序的目录下执行了npm init，初始化了项目，然后执行npm search gb2312发现并使用了如下模块fast-gbk | encode and decode… | =song940 | 2019-06-17 | 0.0.1 | gbk。使用npm install --production fast-gbk安装该模块，但是光做到这里还没办法在项目中使用该模块。我们还需要在微信开发者工具的设置-&gt;项目设置里勾选使用npm模块，之后还需要点击工具-&gt;构建npm。之后开发者工具会进行如下操作: 首先 node_modules 目录不会参与编译、上传和打包中，所以小程序想要使用 npm 包必须走一遍“构建 npm”的过程，在最外层的 node_modules 的同级目录下会生成一个 miniprogram_npm 目录，里面会存放构建打包后的 npm 包，也就是小程序真正使用的 npm 包。构建打包分为两种：小程序 npm 包会直接拷贝构建文件生成目录下的所有文件到 miniprogram_npm 中；其他 npm 包则会从入口 js 文件开始走一遍依赖分析和打包过程（类似 webpack）。寻找 npm 包的过程和 npm 的实现类似，从依赖 npm 包的文件所在目录开始逐层往外找，直到找到可用的 npm 包或是小程序根目录为止。 按理说在进行了上述操作之后应该已经可以导入并使用模块了,然而当我尝试使用const { encode, decode } = require('fast-gbk');的时候，出现报错module “miniprogram_npm/fast-gbk/codes.json”,原始的npm文件夹中应该有一个codes.json文件记录了编码，然而重新打包之后的文件夹中竟然漏了这个文件，看来其他 npm 包则会从入口 js 文件开始走一遍依赖分析和打包过程（类似 webpack）也不是完全的可靠啊。于是我把json文件中的所有内容直接复制到了打包后的程序入口index.js中，问题最终解决。 GB2312十六进制解码fast-gbk的readme里的示例已经很清楚了，对于形似CE C2 B6 C8 3A 32 37 20 43 2C CA AA B6 C8 3A 34 38 20 25 20 0D 0A这样的数据包我的解码方式如下。（第三方包已经处理好了ASCII字符与全角字符的区别） 123456789function hexToString(hexString) { let hexArr = hexString.toLowerCase().split(' '); let codeArr = []; for (let i = 0; i &lt; hexArr.length; i++) { let fb = parseInt(hexArr[i], 16); codeArr.push(fb); } console.log(decode(codeArr));}","link":"/posts/wechatapp-npm.html"},{"title":"wordpress使用自定义字体","text":"使用本地自定义字体在wordpress上如果我们不满足于原版的字体我们可以引入更多的字体，这篇文章记录了我是如何为网站标题加上自定义字体的。 获得字体包提供字体的网站有很多，我的网站标题字体来自方正字库的郑明瑾秀丽笔行书,下载字体时注意区分好字体的授权种类，比如我使用的字体授权为免费非商用，乱用字体小心律师函😋。 大部分字体包都包含成千上万个文字，比如我这个字体包下载下来一看有10MB，这么大的文件我们不应该直接放到网站上因为这回大大的拖慢访问速度，那么我们能不能只抽出字体包中的部分字体使用呢？ 工具FontZip可以满足我们的需求，我们可以使用该工具提取我们需要的文字，精简字体包。选择好字体，输入我们需要提取的文字后点击Ok，在和源字体相同的目录下将会生成名为fontzipMin.ttf的ttf文件。 上传字体包并使用在主题所在的目录下创建font文件夹并把精简后的字体包放进去(注意需要给与文件755权限)，之后使用wordpress的自定义主题中的额外css或者使用的主题自带的自定义CSS样式功能，把我们的字体给网站标题加上。 123@font-face { font-family: hj; src: url(https://blog.notesail.com/wp-content/themes/Sakura/font/min-ZMJXLBXSJ.ttf); font-weight: normal; }.site-name {font-family: hj;font-size: 30px;} 保存之后刷新网站，字体应该就生效了。","link":"/posts/wordpress-custom-font.html"},{"title":"ubuntu手动安装lnmp+Typecho","text":"手动安装配置lnmp+typecho这两天寻思着弄一个动态网站作为个人日常的博客，又不太想用wordpress这过于”重量级”的cms，想起了以前也用过的typecho，但是安装过程中遇见了一些困难，发现现在网上极其缺少手动安装typecho的教程，不是过时的教程就是宝塔一键脚本一起上…所以我还是分享一下我是如何安装typecho的吧。 安装lnmp我们首先准备typecho的环境，lnmp即(linux + nginx + mysql + php)。我使用的系统是Ubuntu 1804，所有Debian系的系统操作应该都类似，其他系的系统需要修改一下指令。 安装phpsudo apt install php-fpm php-common php-mbstring php-xmlrpc php-soap php-gd php-xml php-intl php-mysql php-cli php-ldap php-zip php-curl 如果要修改php的配置如上传文件限制内存上限等等，编辑 sudo nano /etc/php/7.2/fpm/php.ini 文件即可。 (adsbygoogle = window.adsbygoogle || []).push({}); nginx安装并配置php/https1apt install nginx 配置https安装好nginx后，我们编辑站点配置文件,把里面的server_name的example.com修改成你自己的域名(当然域名要设置好A记录解析到当前服务器上) 1nano /etc/nginx/sites-available/default 然后使用certbot自动申请配置ssl证书，采取certbot的官方教程(官方有各个发行版的详细教程)。 1234567sudo apt-get updatesudo apt-get install software-properties-commonsudo add-apt-repository universesudo add-apt-repository ppa:certbot/certbotsudo apt-get updatesudo apt-get install certbot python-certbot-nginxsudo certbot --nginx 运行certbot后，会先要求你输入邮箱，如果之前对站点配置文件没配置错的话，那应该就能看见你的域名，选择该域名，certbot便会自动申请配置证书，最后还会选择是否要把http重定向为https，选择redirect即可。完成之后再访问你的域名，理论上能以https的方式访问到nginx的默认index.html。 配置php同样编辑站点配置文件 /etc/nginx/sites-available/default ，在server的大括号中添加如下内容。 12345location ~ \\.php$ {include snippets/fastcgi-php.conf;fastcgi_pass unix:/var/run/php/php7.2-fpm.sock;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;} 之后重启一下nginx,在 /var/www/html 目录下创建一个info.php文件，写入 123&lt;?php phpinfo();?&gt; 再访问你的域名/info.php，如果显示如下就配置成功了。 (adsbygoogle = window.adsbygoogle || []).push({}); 安装配置mysqltypecho其实还支持sqlite，直接安装php的sqlite扩展以及sqlite3就可以使用了，但是由于我使用的插件在使用sqlite时会出错，所以我还是改用了mysql。 sudo apt install mysql 接着我们需要创建typecho的用户以及相应的数据库并赋权。 123456mysql -u root -pCREATE DATABASE typecho;CREATE USER 'typecho'@'localhost' IDENTIFIED BY '123456';GRANT ALL ON typecho.* TO 'typecho'@'localhost' IDENTIFIED BY '123456';FLUSH PRIVILEGES;EXIT; 安装Typecho之前的步骤做完后我们已经准备好了lnmp环境了，接着就是安装typecho。 前往Typecho的网站获取下载链接。 123456### 在/var/www/html 里面执行wget https://typecho.org/downloads/1.1-17.10.30-release.tar.gztar -zxvf 1.1-17.10.30-release.tar.gzmv build typechochown -R www-data:www-datachmod -R 755 typecho 另外还建议修改 /etc/nginx/sites-available/default 将站点根目录修改为 /var/www/html/typecho 并重启一下nginx。 之后访问 https://yourdomain/install.php （如果没改根目录的话就是/typecho/install.php） 配置时，数据库名字，用户名，密码都改成之前创建数据库时使用的参数就好，如果没有什么其他的问题，完成几步操作之后便安装成功了。 伪静态设置默认的typecho网页链接中总带着一个index.php，那么有没有办法把这个链接美化一下呢？我们需要开启typecho的伪静态。首先编辑nginx的站点文件，在server大括号中加入 123456789if (-f $request_filename/index.html){rewrite (.*) $1/index.html break;}if (-f $request_filename/index.php){rewrite (.*) $1/index.php;}if (!-f $request_filename){rewrite (.*) /index.php;} 并前往typecho控制面板的设置/永久链接中打开启用地址重写功能(可能会提示不可用，还是选择应用即可)然后重启一下nginx。再看，index.php已经没了。 (adsbygoogle = window.adsbygoogle || []).push({});","link":"/posts/setup-typecho.html"},{"title":"macvlan模式容器与宿主机通信","text":"如何让macvlan模式的容器与宿主机通信前段时间使用到了docker的macvlan模式，这个模式通俗一点讲就是在一张物理网卡上虚拟出两个虚拟网卡，具有不同的MAC地址，可以让宿主机和docker同时接入网络并且使用不同的ip，此时docker可以直接和同一网络下的其他设备直接通信，相当的方便，但是这种模式有一个问题，宿主机和容器是没办法直接进行网络通信的，如宿主机ping容器的ip，尽管他们属于同一网段，但是也是ping不通的，反过来也是。因为该模式在设计的时候，为了安全禁止了宿主机与容器的直接通信，不过解决的方法其实也很简单——宿主机虽然没办法直接和容器内的macvlan接口通信，但是只要在宿主机上再建立一个macvlan，然后修改路由，使数据经由该macvlan传输到容器内的macvlan即可，macvlan之间是可以互相通信的。 具体一些的教程可以查看USING DOCKER MACVLAN NETWORKS With a container attached to a macvlan network, you will find that while it can contact other systems on your local network without a problem, the container will not be able to connect to your host (and your host will not be able to connect to your container). This is a limitation of macvlan interfaces: without special support from a network switch, your host is unable to send packets to its own macvlan interfaces. Fortunately, there is a workaround for this problem: you can create another macvlan interface on your host, and use that to communicate with containers on the macvlan network. 原文中针对的情形是将网络下的某一网段就分配给docker容器，使宿主机可以和这些容器互相通信，而我当前只需要使宿主机和一个容器可以通信即可，所以命令会有一些不同。 假设所在网络的网段为 192.168.0.0/24 容器通过macvlan获得的ip为 192.168.0.100 1234567# 以下操作都在宿主机上运行，新增一个叫mynet(不要和容器的macvlan重名)的macvlan接口ip link add mynet link eth0 type macvlan mode bridge# 为该接口分配ip，并启用ip addr add 192.168.0.10 dev mynetip link set mynet up# 修改路由，使宿主机到192.168.0.100的通信全部经由mynet进行ip route add 192.168.0.100 dev mynet 完成这些配置后，再次在宿主机中使用ping 192.168.0.100可以发现已经可以和容器直接通信了。 还有一点需要注意的是，重启后自己创建的macvlan接口会消失，我的方法是把上述命令都写到了rc.local内。 (adsbygoogle = window.adsbygoogle || []).push({});","link":"/posts/macvlan-host.html"},{"title":"菜鸟论坛后端开发记录(二)","text":"程序访问控制管理系列记录: 菜鸟论坛后端开发记录(一) 菜鸟论坛后端开发记录(二) 用户角色与权限 Shiro基本配置 用户信息加密与用户认证 测试 用户注册 用户登录 用户授权与角色权限管理 测试 本节参考 参考资源 计划添加session和shiro的支持即用户登录鉴权以及会话管理(当然一天不太可能踩得完这些坑)。 “用户-角色-权限”管理 https://learner.blog.csdn.net/article/details/101121899 “用户-角色-权限”管理是 “访问控制” 的一种实现方式，更为专业的叫法为 RBAC（Role-Based Access Control），即基于角色的权限访问控制。不少地方提到RBAC 具有三个特性，或者说支持三个原则：最小权限原则，责任分离原则和数据抽象原则，这玩意儿就是骚话，没什么实际意义，有兴趣的自行百度（如果有面试的问这种问题，只能说明他是个瓜皮）。 我觉得关于 RBAC，最重要的是理解为什么要在用户和权限之间加上角色这一层，而不是直接把权限赋给用户。这个问题一点也不难，考虑需要修改用户权限的情形，给一两个用户设置权限没什么问题，但如果有成千上万个用户需要同时获取或去除同一个权限，那可费老劲了，但通过角色来完成这个工作就十分便捷。这实际上也是一种 “解耦” 的思路。 目前对于访问权限的控制几乎全部采用这种方式，差异在于能实现到什么程度。上篇文章提到过权限的三种粒度：菜单权限、操作/功能权限、数据权限。此外还有一些额外的功能，比如互斥性检验（一个角色不能同时拥有两种互斥的权限）、角色继承（新建角色时继承某一角色的权限）等。 本项目使用shiro框架来实现权限管理。Shiro教程 Shiro 是一个强大且易用的 Java 安全框架，可以用来实现身份验证（authentication）、授权（authorization）、加密（cryptography）和会话管理（session managment） 在pom.xml中添加依赖 1234567&lt;!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-all --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-all&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; 用户角色与权限我们要用三张表来分别储存用户、角色、权限，他们之间是一对多的关系，如一个用户可能有多个角色，而一个角色会有多个权限，分别创建三个实体类。 User、Role、Permission， 这里不贴具体代码了，但是遇到的问题记录一下，当我尝试在User中使用一个List来保存对应的多个Role时出现了Basic’ attribute type should not be a container的提示，经过查询，需要我们手动指名对应关系即可。在该List上添加注解@OneToMany(targetEntity = Role.class)便不再报错了。 贴一下当前数据库中这三个实体都有什么属性(仅对于登录授权这个环节) User: 字段名 类型 介绍 id Long 用户在数据库中的id account String 账户 password String 密码 email String 邮箱 salt String 加密时用的盐 roleSet Set 用户所具有的角色 Role: 字段名 类型 介绍 id Long Role在表中id roleName String 角色名 permissionSet Set 角色拥有的权限 Permission: 字段名 类型 介绍 id Long 在表中id permissionName String 权限名 注意，使用这样的对象结构在使用JPA储存的时候出现了报错 object references an unsaved transient instance - save the transient instance before flushing” error 通过查询，发现当实体对象中有一个集合，且集合中包含有数据库中没有的实体，就会出现这个错误，我们需要添加注解@Cascade(value = org.hibernate.annotations.CascadeType.ALL)，来告诉hibernate在保存对象时自动保存他们中的集合内的对象。 Shiro基本配置首先创建Realm类 Realm： 是 Shiro 和安全相关数据（比如用户信息）的桥梁，也就是说，Realm 负责从数据源中获取数据并加工后传给 SecurityManager。 我们可以通过配置使用特定的 Realm 替代 DAO，和 JPA 类似，Realm 获取数据的方法被封装了起来，但是数据库中的表名、字段等需要与源码预定义的查询保持一致，所以在我们的项目中获取数据的功能仍旧可以交给 JPA 完成，Realm 只负责加工并传递这些数据。 12345678910111213141516171819202122232425262728293031323334353637package com.aoyouer.noobserver.shiro;import com.aoyouer.noobserver.entitiy.User;import com.aoyouer.noobserver.service.UserService;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.util.ByteSource;import javax.annotation.Resource;public class NoobRealm extends AuthorizingRealm { @Resource UserService userService; //需要重写（实现）授权信息获取方法 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { return new SimpleAuthorizationInfo(); } //根据token中的用户名从数据库中获取密码和盐 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { String userAccount = authenticationToken.getPrincipal().toString(); User user = userService.getUserByAccount(userAccount); //获取数据库中的密码（hash加密后） String passwordInDB = user.getPassword(); String salt = user.getSalt(); //SimpleAuthenticationInfo中的salt使用的是byte[]而我们储存的是字符串 return new SimpleAuthenticationInfo(userAccount,passwordInDB, ByteSource.Util.bytes(salt),getName()); }} 我们还需要一个Shiro配置类，(来自于网上) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.aoyouer.noobserver.shiro;import org.apache.shiro.authc.credential.HashedCredentialsMatcher;import org.apache.shiro.spring.LifecycleBeanPostProcessor;import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.apache.shiro.mgt.SecurityManager;@Configurationpublic class ShiroConfig { @Bean public static LifecycleBeanPostProcessor getLifecycleBeanProcessor() { return new LifecycleBeanPostProcessor(); } @Bean public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) { ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager); return shiroFilterFactoryBean; } @Bean public SecurityManager securityManager() { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(getNoobRealm()); return securityManager; } @Bean public NoobRealm getNoobRealm() { NoobRealm noobRealm = new NoobRealm(); noobRealm.setCredentialsMatcher(hashedCredentialsMatcher()); return noobRealm; } @Bean public HashedCredentialsMatcher hashedCredentialsMatcher() { HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher(); hashedCredentialsMatcher.setHashAlgorithmName(\"md5\"); hashedCredentialsMatcher.setHashIterations(2); return hashedCredentialsMatcher; } @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) { AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; }} 用户信息加密与用户认证之后我们在controller中添加登录相关代码。 1234567891011121314151617181920212223242526272829303132333435@RestController@RequestMapping(path = \"/api\")public class UserController { @Resource UserService userService; //关于用户登录 @PostMapping(value = \"/login\") public Response login(@RequestBody User user){ String account = user.getAccount(); String password = user.getPassword(); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken usernamePasswordToken = new UsernamePasswordToken(account,password); try{ subject.login(usernamePasswordToken); return new Response(200,\"登陆成功:\" + account); }catch (AuthenticationException e){ return new Response(200,\"登陆失败\"); } }} //用户注册 @PostMapping(value = \"/register\") public Response register(@RequestBody User user){ try { //用账户作为盐 user.setPassword(Encrypt.encrypt(user.getPassword(),user.getAccount())); //添加用户到数据库中，这里可能会抛出异常——账户重名(其实还应该检查一下输入的合法性，虽然前端可以检查，但是有可能被绕过 user.setSalt(user.getAccount()); userService.registerUser(user); return new Response(200,\"已成功注册\"); }catch (RegisterException e){ return new Response(400,e); } } 需要注意的是，这里的密码需要和盐进行hash加密，使用的算法和加密次数都要和Shiro配置类中的设置对应。 123456public class Encrypt { public static String encrypt(String pwd,String salt){ //注意这里的加密算法和加密次数要和Shiro配置类里面的对应 return new SimpleHash(\"SHA-256\",pwd,salt,2).toString(); }} 使用了Shiro框架之后，服务端也会记录客户端“登陆成功”的状态，那么我们还需要实现“注销登录”的方法，前后端分离项目中，前后端都要对注销登录做出处理，这里先写后端需要做的。 测试用户注册使用postman构造post请求，成功注册。 查看数据库，确实已经加上了。 用户登录 成功登录 使用错误的密码再试一次 符合预期。 用户授权与角色权限管理用户、角色、权限之间的关系查看第一节(用户角色与权限)。 用户登陆后在之后的请求中也需要有带有一些信息来证明自己是谁，关于认证有Session和Token等方案，可以查看https://learner.blog.csdn.net/article/details/102788866学习。 而在客户端拿到Session id或者Token之后也需要在储存，方案有cookie、localStorage 和 sessionStorage，参考https://www.cnblogs.com/minigrasshopper/p/8064367.html，对他们进行对比。 通常来说，在可以使用 cookie 的场景下，作为验证用途进行传输的用户名密码、sessionId、token 直接放在 cookie 里即可。而后端传来的其它信息则可以根据需要放在 local/session Storage 中，作为全局变量之类进行处理。 Shiro的安全管理基于Session，所以我们也使用Session来实现用户认证与授权。上一节使用到的subject.login()方法就生成了一个session并把sessionid设置到了cookie中，之后我们的请求中只要带上这个cookie就知道当前的用户(Subject具有什么权限，属于哪个角色了)。 为了实现角色与权限的管理，我们需要完善Shiro核心类，之前在用户注册的时候我们创建了AuthorizingRealm的子类NoobRealm，并重写完善了它的doGetAuthenticationInfo方法，该方法用于认证(即用户的登录过程),而还有另一个需要重写的方法doGetAuthorizationInfo,该方法用于授权，即判断用户是否有权限执行操作，在该方法中我们需要自行获取用户的角色与权限并放到返回的AuthorizationInfo授权信息中。 Shiro中的Authentication 是用来验证用户身份，Authorization 是授权访问控制，用于对用户进行的操作授权，证明该用户是否允许进行当前操作，如访问某个链接，某个资源文件等。 用户进行权限验证时候Shiro会去缓存中找,如果查不到数据,会执行这个方法去查权限,并放入缓存中,至于如何查找，需要我们自己实现。 参考： https://zhuanlan.zhihu.com/p/98365213 12345678910111213141516171819202122232425@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { System.out.println(principalCollection); SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); //TODO 研究这里面到底是什么 logger.info(\"principalCollection.getPrimaryPrincipal()\" + principalCollection.toString()); User user = userService.getUserByAccount(principalCollection.getPrimaryPrincipal().toString()); logger.info(\"授权中:\" + user.getAccount()); //授权管理 Set&lt;String&gt; roleNameSet = new HashSet&lt;&gt;(); Set&lt;String&gt; permissionNameSet = new HashSet&lt;&gt;(); //从数据库中查询用户 User dbUser = userService.getUserByAccount(user.getAccount()); Set&lt;Role&gt; roleSet = dbUser.getRoleSet(); for (Role role:roleSet){ roleNameSet.add(role.getRoleName()); for (Permission permission : role.getPermissionSet()){ permissionNameSet.add(permission.getPermissionName()); } } //将查到的权限和角色分别传入authorizationInfo中 simpleAuthorizationInfo.setStringPermissions(permissionNameSet); simpleAuthorizationInfo.setRoles(roleNameSet); return simpleAuthorizationInfo;} 之后为了便于限制权限，我们可以开启Shiro注解的方式来管理，但是需要我们在Shiroconfig里面增加两个方法。 123456789101112131415161718/** * 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions),需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证 * 配置以下两个bean(DefaultAdvisorAutoProxyCreator(可选)和AuthorizationAttributeSourceAdvisor)即可实现此功能 */@Bean@DependsOn({\"lifecycleBeanPostProcessor\"})public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator() { DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator(); advisorAutoProxyCreator.setProxyTargetClass(true); return advisorAutoProxyCreator;}@Beanpublic AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor() { AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager()); return authorizationAttributeSourceAdvisor;} 之后我们便可以使用下面的五个权限注解了 RequiresPermissions 当前Subject需要拥有某些特定的权限时，才能执行被该注解标注的方法。如果当前Subject不具有这样的权限，则方法不会被执行。 这是基于资源权限方式的权限控制主要方案，也是我们项目中进行权限控制使用的注解方案。 RequiresRoles 当前Subject必须拥有所有指定的角色时，才能访问被该注解标注的方法。如果当天Subject不同时拥有所有指定角色，则方法不会执行还会抛出AuthorizationException异常。 RequiresUser 当前Subject必须是应用的用户，才能访问或调用被该注解标注的类，实例，方法。 RequiresAuthentication 使用该注解标注的类，实例，方法在访问或调用时，当前Subject必须在当前session中已经过认证。 RequiresGuest 使用该注解标注的类，实例，方法在访问或调用时，当前Subject可以是“gust”身份，不需要经过认证或者在原先的session中存在记录。 之后我们可以在需要检查权限/角色的方法上添加类似于@RequiresRoles(value = {&quot;ADMIN&quot;,&quot;MANAGER&quot;,&quot;MEMBER&quot;},logical = Logical.OR)这样的注解即可。 另外，权限不足的时候会抛出AuthorizationException异常，要处理该异常也可以使用在异常处理方法上添加注解的方式来注明。 12345//授权失败异常处理(即权限不足)@ExceptionHandler(AuthorizationException.class)public Response authorExceptionHandler(AuthorizationException e){ return new Response(403,\"授权验证失败\" + e.getMessage());} 测试默认注册时的用户角色都是MEMBER(目前我还没有细分权限管理，所以只看角色)，而我添加了一个adduser的方法，要求的角色是@RequiresRoles(value = {&quot;ADMIN&quot;,&quot;MANAGER&quot;},logical = Logical.OR)，我们可以查看是否能够执行。 我们先登录 注意登陆成功后会返回cookie 之后我们尝试使用/api/adduser来添加一个用户，注意要在Headers中带上cookie 发现该请求确实被拦截了，并且异常处理函数也正常调用了。我们再尝试修改代码，向该方法的注解中添加MEMBER，再次运行。 这时候我还没登录，直接运行，也是错误的，提示不允许使用匿名的Subject，先登录再再次请求，成功添加了用户。 本节参考https://learner.blog.csdn.net/article/details/102788866 https://blog.csdn.net/weixin_45492007/article/details/102076816 https://cloud.tencent.com/developer/article/1448332 (开启权限注解) 参考资源 访问控制及其实现思路 使用 Shiro 实现用户信息加密与登录认证 Shiro教程 Apache Shiro中使用注解来实现角色控制和权限控制 Shiro核心类编写 Shiro认证与授权 springboot + shiro 实现登录认证和权限控制 SpringBoot 整合 Shiro 实现动态权限加载更新+ Session 共享 + 单点登录","link":"/posts/noob-bbs-server-2.html"},{"title":"菜鸟论坛后端开发记录(一)","text":"项目起步与数据库基础系列记录: 菜鸟论坛后端开发记录(一) 菜鸟论坛后端开发记录(二) 创建Spring boot项目 将Spring boot项目部署到服务器上运行 安装并配置数据库 服务器安装数据库 程序与数据库连接 创建实体类Entity 创建Repository接口 创建Service类 创建Controller类 测试 参考 因为专业实训想要开发一个小型的论坛，但是由于大家对于相关的技术都不熟悉（会），所以写这篇文章来记录，分享学习与开发的过程。 创建Spring boot项目使用Spring boot可以帮助我们快速开始后端程序的开发，之前接触过一点，所以这次还是使用了Spring boot作为后端框架。 在IDEA新建项目的时候选择spring，并选择WEB-Spring Web项目 之后会花费比较长的一段时间构建项目，构建好项目之后点击RUN，即可开始运行，当然一开始访问8080端口什么都没有，因为我们还什么都没有做。 将Spring boot项目部署到服务器上运行我们可以将Spring boot先打包成jar包，然后上传到服务器上运行，首先点击右侧的Maven标签，然后先点击clean清除之前的jar包，然后再点击package将当前的jar包打包，打包成功之后会显示jar包路径（target目录），前往这个目录找到jar包。 并使用xftp将该jar包传到服务器上 为了避免多人同时启动程序失败的情况，请大家在tmux中运行服务端程序，tmux的用法请自行搜索。 tmux a -t server,使用root@0e76573e9698:/home/server# java -jar noobserver-0.0.1-SNAPSHOT.jar来启动程序，可以看到程序已经开始运行了，之后即可通过http://bbs.aoyouer.com:8080来请求服务端，当然一开始什么都没有。 安装并配置数据库服务器安装数据库123456789#我在docker中运行出现了Failed t的错误o start MySQL Community Server.的错误，且无法找到解决方法，所以我改用了mariadbapt install mariadb-serversystemctl start mysqlmysql_secure_installationmysql#创建新用户与数据库MariaDB [(none)]&gt; CREATE USER 'noob'@'%' IDENTIFIED BY 'hustxxxx';MariaDB [(none)]&gt; GRANT ALL ON *.* TO 'noob'@'%';MariaDB [(none)]&gt; CREATE DATABASE noob_bbs; 接着，我尝试远程连接数据库的时候出现了报错 ERROR 2013 (HY000): Lost connection to MySQL server at ‘reading initial communication packet’, system error: 0 “Internal error/check (Not system error)”,经过查询，解决方法如下，编辑 /etc/mysql/mariadb.conf.d/50-server.cnf 文件，注释掉bind-address这一行。 123# Instead of skip-networking the default is now to listen only on# localhost which is more compatible and is not less secure.#bind-address = 127.0.0.1 之后便可以远程连接了(其实并没有必要，不过我不想在本地装mysql了，所以直接连接到远程的服务器上的数据库进行开发) 为了便于操作，我们可以直接使用IDEA内置的插件打开服务器上的数据库 程序与数据库连接接着我们要尝试让我们的程序连接到数据库，先添加依赖，修改maven的pom.xml 添加如下依赖 12345678910 &lt;!-- MYSQL --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mariadb.jdbc&lt;/groupId&gt; &lt;artifactId&gt;mariadb-java-client&lt;/artifactId&gt;&lt;/dependency&gt; &lt;!-- Spring Boot JPA --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; 然后在application.properties或application.yml文件中配置数据库连接，关于hibernate 我编辑的是application.properties 123456spring.datasource.url=jdbc:mysql://bbs.aoyouer.com:3307/noob_bbsspring.datasource.username=noobspring.datasource.password=hustsenoob_bbsspring.datasource.driver-class-name=org.mariadb.jdbc.Driverspring.jpa.hibernate.ddl-auto=updatespring.jpa.show-sql=true jpa需要我们用到 Entity，Repository，Controller 我们首先创建Entity类，此类的对象将会被持久化成数据库中的信息，如我们要有一个数据表记录用户，那么我先创建DemoUserEntity类，如果添加@Entity注解后，无法识别（下面还是红色波浪线），使用alt+enter并加入依赖即可。 创建实体类Entity首先我们创建用户实体类 DemoUserEntity,该对象的属性都会映射成数据库表中的字段。如该实体类有 id, account, password, email几个字段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.aoyouer.noobserver.entities;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import javax.persistence.*;@Entity//@Table(name=\"t_demouser\") 可以自定义表名public class DemoUserEntity { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String account; private String password; private String email; public DemoUserEntity() { } public DemoUserEntity(String account, String password, String email) { this.account = account; this.password = password; this.email = email; } public String getAccount() { return account; } public void setAccount(String account) { this.account = account; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; }} 创建Repository接口Repository是实际用来操作数据库的接口，在这个接口中我们可以定义程序如何操作数据库，我们还可以添加一个自定义方法，如根据用户名查找用户。 注意，这些方法的命名都有一套规范，只要按照规范命名，这些方法就不需要自己实现，就可以使用 参考https://blog.csdn.net/sbin456/article/details/53304148 注意里面的方法 12345678package com.aoyouer.noobserver.repository;import com.aoyouer.noobserver.entities.DemoUserEntity;import org.springframework.data.repository.CrudRepository;public interface DemoUserRepository extends CrudRepository&lt;DemoUserEntity,Long&gt; { DemoUserEntity findDemoUserEntityByAccount(String account);} 创建Service类之前的操作有一点不恰当的地方，我在Controller中直接使用了Repository，但是规范来说应该先创造Service类，Controller类通过Service类来操作Repository。至于为什么要这么做,以及它们的区别。 https://blog.csdn.net/Dream_Weave/article/details/84534800 https://www.cicoding.cn/spring/whats-the-difference-between-component-repository-service-controller-annotations-in/ 123456789101112131415161718192021222324252627package com.aoyouer.noobserver.service;import com.aoyouer.noobserver.entitiy.DemoUserEntity;import com.aoyouer.noobserver.repository.DemoUserRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import javax.annotation.Resource;@Servicepublic class DemoUserService { @Resource private DemoUserRepository demoUserRepository; @Transactional public void save(DemoUserEntity demoUserEntity){ demoUserRepository.save(demoUserEntity); } @Transactional public DemoUserEntity getDemoUserByAccount(String account){ return demoUserRepository.findDemoUserEntityByAccount(account); }} 创建Controller类controller类关系到和用户的交互操作，如接受请求并调用repository的方法操作数据库。 12345678910111213141516171819202122232425262728293031323334353637383940package com.aoyouer.noobserver.controller;import com.aoyouer.noobserver.entitiy.DemoUserEntity;import com.aoyouer.noobserver.repository.DemoUserRepository;import com.aoyouer.noobserver.service.DemoUserService;import com.aoyouer.noobserver.utils.Response;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;@Controller//下面这个注解可以让controller返回json格式数据@RestController@RequestMapping(path = \"/api\")public class DemoUserController { @Resource DemoUserService demoUserService; //响应GET方法,注意下面的@RequestParam注解，该请求需要有account=xxx的参数 @GetMapping(path = \"/getdemouser\") public Response getDemoUser(@RequestParam String account){ //使用我们在接口中定义的方法 DemoUserEntity demoUserEntity = demoUserService.getDemoUserByAccount(account); //这里我们已经取出了数据表中的对象 return new Response(200,demoUserEntity); } //添加用户的方法，这里使用的是GET，之后实际应该要使用POST方法 @GetMapping(path = \"/adddemouser\") public Response addDemoUser(@RequestParam String account,@RequestParam String password, @RequestParam String email){ DemoUserEntity demoUserEntity = new DemoUserEntity(account,password,email); //save方法不需要我们自己声明，接口中已经有了 demoUserService.save(demoUserEntity); return new Response(200,\"成功添加用户\"); }} 测试之后便可以开始运行了。 首先尝试请求 http://localhost:8080/api/getdemouser?account=admin,查看后台，发现出错了，因为此时我们连数据表都没有创建。。需要在之前的`application.properties`中添加一行(现在已经加上了)。 spring.jpa.hibernate.ddl-auto=update 设置自动创建表之后重启程序，可以看到数据表已经创建了。 先请求http://localhost:8080/api/getdemouser?account=admin，不过由于这个时候数据库中还没有记录 那我们尝试添加一个对象吧 http://localhost:8080/api/adddemouser?account=admin&amp;password=hahaha&amp;email=aoyouer@qq.com 查看后台，执行了对应的sql 再查看数据库 再次使用第一个请求,成功获取到了数据。 参考 Spring boot中的注解 Spring boot入门 https://www.yiibai.com/spring-boot/spring_boot_introduction.html 聊聊@Repository、@Component、@Controller、@Service有什么区别 JPA数据查询 Apache Shiro Websocket加入 JPA查询方法命名 https://blog.csdn.net/sbin456/article/details/53304148","link":"/posts/noob-bbs-server-1.html"}],"tags":[{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"虚拟机","slug":"虚拟机","link":"/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"建站","slug":"建站","link":"/tags/%E5%BB%BA%E7%AB%99/"},{"name":"折腾","slug":"折腾","link":"/tags/%E6%8A%98%E8%85%BE/"},{"name":"metasploit","slug":"metasploit","link":"/tags/metasploit/"},{"name":"Minecraft","slug":"Minecraft","link":"/tags/Minecraft/"},{"name":"Minecraft服务器","slug":"Minecraft服务器","link":"/tags/Minecraft%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"bugs","slug":"bugs","link":"/tags/bugs/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"telegram","slug":"telegram","link":"/tags/telegram/"},{"name":"分享","slug":"分享","link":"/tags/%E5%88%86%E4%BA%AB/"},{"name":"cdn","slug":"cdn","link":"/tags/cdn/"},{"name":"wine","slug":"wine","link":"/tags/wine/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"kvm","slug":"kvm","link":"/tags/kvm/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"编程学习","slug":"编程学习","link":"/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"wordpress","slug":"wordpress","link":"/tags/wordpress/"},{"name":"技巧","slug":"技巧","link":"/tags/%E6%8A%80%E5%B7%A7/"},{"name":"typecho","slug":"typecho","link":"/tags/typecho/"},{"name":"docker网络","slug":"docker网络","link":"/tags/docker%E7%BD%91%E7%BB%9C/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"专业实训","slug":"专业实训","link":"/tags/%E4%B8%93%E4%B8%9A%E5%AE%9E%E8%AE%AD/"},{"name":"shiro","slug":"shiro","link":"/tags/shiro/"},{"name":"jpa","slug":"jpa","link":"/tags/jpa/"},{"name":"spring boot","slug":"spring-boot","link":"/tags/spring-boot/"}],"categories":[{"name":"杂谈","slug":"杂谈","link":"/categories/%E6%9D%82%E8%B0%88/"},{"name":"折腾","slug":"杂谈/折腾","link":"/categories/%E6%9D%82%E8%B0%88/%E6%8A%98%E8%85%BE/"},{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"分享","slug":"杂谈/分享","link":"/categories/%E6%9D%82%E8%B0%88/%E5%88%86%E4%BA%AB/"},{"name":"实践","slug":"技术/实践","link":"/categories/%E6%8A%80%E6%9C%AF/%E5%AE%9E%E8%B7%B5/"},{"name":"学习","slug":"技术/学习","link":"/categories/%E6%8A%80%E6%9C%AF/%E5%AD%A6%E4%B9%A0/"}]}